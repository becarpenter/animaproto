<?xml version="1.0" encoding="utf-8"?>
<!-- This is built from a template for a generic Internet Draft. Suggestions for
     improvement welcome - write to Brian Carpenter, brian.e.carpenter @ gmail.com 
     This can be converted using the Web service at http://xml.resource.org/ -->
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">
<?rfc toc="yes"?>
<!-- You want a table of contents -->
<?rfc symrefs="yes"?>
<!-- Use symbolic labels for references -->
<?rfc sortrefs="yes"?>
<!-- This sorts the references -->
<?rfc iprnotified="no" ?>
<!-- Change to "yes" if someone has disclosed IPR for the draft -->
<?rfc compact="yes"?>
<!-- This defines the specific filename and version number of your draft (and inserts the appropriate IETF boilerplate -->
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="std" docName="draft-ietf-anima-grasp-15" ipr="trust200902" obsoletes="" updates="" submissionType="IETF" xml:lang="en" tocInclude="true" symRefs="true" sortRefs="true" version="3">
  <!-- xml2rfc v2v3 conversion 2.40.1 -->
  <front>
    <title abbrev="GRASP">A Generic Autonomic Signaling Protocol (GRASP)</title>
    <seriesInfo name="Internet-Draft" value="draft-ietf-anima-grasp-15"/>
    <author initials="C." surname="Bormann" fullname="Carsten Bormann">
      <organization>Universit√§t Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>D-28359 Bremen</city>
          <country>Germany</country>
        </postal>
        <email>cabo@tzi.org</email>
      </address>
    </author>
    <author fullname="Brian Carpenter" initials="B. E." surname="Carpenter" role="editor">
      <organization abbrev="Univ. of Auckland"/>
      <address>
        <postal>
          <street>Department of Computer Science</street>
          <street>University of Auckland</street>
          <street>PB 92019</street>
          <city>Auckland</city>
          <region/>
          <code>1142</code>
          <country>New Zealand</country>
        </postal>
        <email>brian.e.carpenter@gmail.com</email>
      </address>
    </author>
    <author fullname="Bing Liu" initials="B." surname="Liu" role="editor">
      <organization>Huawei Technologies Co., Ltd</organization>
      <address>
        <postal>
          <street>Q14, Huawei Campus</street>
          <street>No.156 Beiqing Road</street>
          <city>Hai-Dian District, Beijing</city>
          <code>100095</code>
          <country>P.R. China</country>
        </postal>
        <email>leo.liubing@huawei.com</email>
      </address>
    </author>
    <!---->

    <date year="2020"/>
    <abstract>
      <t>This document specifies the GeneRic Autonomic Signaling Protocol (GRASP), which
      enables autonomic nodes and autonomic service agents to dynamically discover peers,
      to synchronize state with each other, and to negotiate parameter settings with each
      other. GRASP depends on an external security environment that is described
      elsewhere. The technical objectives and parameters for specific application scenarios
      are to be described in separate documents. Appendices briefly discuss requirements
      for the protocol and existing protocols with comparable features.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="intro" numbered="true" toc="default">
      <name>Introduction</name>
      <t>The success of the Internet has made IP-based networks bigger and
      more complicated. Large-scale ISP and enterprise networks have become more and more
      problematic for human based management. Also, operational costs are growing quickly.
      Consequently, there are increased requirements for autonomic behavior in the networks.
      General aspects of autonomic networks are discussed in
      <xref target="RFC7575" format="default"/> and <xref target="RFC7576" format="default"/>. </t>
      <t>One approach is to largely decentralize the logic of network management by migrating it
      into network elements. A reference model for autonomic networking on this basis is given in
      <xref target="I-D.ietf-anima-reference-model" format="default"/>. The reader should consult this document
      to understand how various autonomic components fit together.
      In order to fulfill autonomy, devices that embody Autonomic Service Agents
      (ASAs, <xref target="RFC7575" format="default"/>)
      have specific signaling requirements. In particular they need to discover each other,
      to synchronize state with each other,
      and to negotiate parameters and resources directly with each other.
      There is no limitation on the types of parameters and resources concerned,
      which can include very basic information needed for addressing and routing,
      as well as anything else that might be configured in a conventional non-autonomic network.
      The atomic unit of discovery, synchronization or negotiation is referred to as a technical
      objective, i.e, a configurable parameter or set of parameters 
      (defined more precisely in <xref target="terms" format="default"/>).</t>
      <t>
      Negotiation is an iterative process, requiring multiple message exchanges forming
      a closed loop between the negotiating entities. In fact, these entities are
      ASAs, normally but not necessarily in different network devices.
      State synchronization, when needed,
      can be regarded as a special case of negotiation, without iteration.
      Both negotiation and synchronization must logically follow discovery.
      More details of the requirements are found in <xref target="reqts" format="default"/>.
      <xref target="highlevel" format="default"/> describes a behavior model for a protocol
      intended to support discovery, synchronization and negotiation. The
      design of GeneRic Autonomic Signaling Protocol (GRASP) in <xref target="Overview" format="default"/>
      of this document is based on this behavior model. The relevant capabilities 
      of various existing protocols are reviewed in <xref target="current" format="default"/>.</t>
      <t>The proposed discovery mechanism is oriented towards synchronization and
      negotiation objectives. It is based on a neighbor discovery process on the
      local link, but also supports diversion to peers on other links.
      There is no assumption of any particular form of network topology.
      When a device starts up with no pre-configuration,
      it has no knowledge of the topology. The protocol itself is capable of
      being used in a small and/or flat network structure such as a small
      office or home network as well as in a large professionally managed network.
      Therefore, the discovery mechanism needs to be able to allow a device
      to bootstrap itself without making any prior assumptions about network
      structure. </t>
      <t>Because GRASP can be used as part of a decision process among distributed
      devices or between networks, it must run in a secure and strongly authenticated
      environment. 
      </t>
      <t>In realistic deployments, not all devices will
      support GRASP. Therefore, some autonomic service agents will directly
      manage a group of non-autonomic nodes, and other non-autonomic nodes
      will be managed traditionally. Such mixed scenarios
      are not discussed in this specification.</t>
    </section>
    <!-- intro -->



    

    <section anchor="Overview" numbered="true" toc="default">
      <name>GRASP Protocol Overview</name>
      <section anchor="terms" numbered="true" toc="default">
        <name>Terminology</name>
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      <xref target="RFC2119" format="default"/> when they appear in ALL CAPS. When these words
      are not in ALL CAPS (such as "should" or "Should"), they have their
      usual English meanings, and are not to be interpreted as <xref target="RFC2119" format="default"/> key words.</t>
        <t>This document uses terminology defined in <xref target="RFC7575" format="default"/>.</t>
        <t>The following additional terms are used throughout this document:
        </t>
        <ul spacing="normal">
          <!-- <t>Autonomic Device: identical to Autonomic Node.</t> -->
          <li>Discovery: a process by which an ASA discovers peers
          according to a specific discovery objective. The discovery results
          may be different according to the different discovery objectives.
          The discovered peers may later be used as negotiation
          counterparts or as sources of synchronization data. </li>
          <li>Negotiation: a process by which two ASAs interact
          iteratively to agree on parameter settings that best satisfy the
          objectives of both ASAs.</li>
          <li>State Synchronization: a process by which ASAs
          interact to receive the current state of parameter
          values stored in other ASAs. This is a special case of negotiation
          in which information is sent but the ASAs do not request
          their peers to change parameter settings. All other definitions
          apply to both negotiation and synchronization. </li>
          <li>
            <t>Technical Objective (usually abbreviated as Objective):
          A technical objective is a data structure, whose main contents
          are a name and a value. The value consists of a single configurable
          parameter or a set of parameters of some kind. The exact
          format of an objective is defined in <xref target="ObjForm" format="default"/>.
          An objective occurs in three contexts: Discovery, Negotiation
          and Synchronization. Normally, a given objective will not
          occur in negotiation and synchronization contexts simultaneously.
          
            </t>
            <ul spacing="normal">
              <li>One ASA may support multiple independent objectives.</li>
              <li>The parameter(s) in the value of a given objective apply to
            a specific service or function or action. They may in principle be
            anything that can be set to a specific logical, numerical or string
            value, or a more complex data structure, by a network node.
            Each node is expected to contain one or more ASAs
            which may each manage subsidiary non-autonomic nodes.</li>
              <li>Discovery Objective: an objective in the process of discovery. Its value
            may be undefined.</li>
              <li>Synchronization Objective: an objective whose specific technical content
            needs to be synchronized among two or more ASAs. Thus, each ASA will maintain
            its own copy of the objective.</li>
              <li>Negotiation Objective: an objective whose specific technical content
            needs to be decided in coordination with another ASA. Again, each ASA will maintain
            its own copy of the objective.</li>
            </ul>
            <t>
            
            A detailed discussion of objectives, including their format, is found in <xref target="ObjOption" format="default"/>.</t>
          </li>
          <li>Discovery Initiator: an ASA that starts discovery
          by sending a discovery message referring to a specific discovery
          objective.</li>
          <li>Discovery Responder: a peer that either contains an ASA supporting the discovery objective
          indicated by the discovery initiator, or caches the locator(s) of the ASA(s) supporting
          the objective. It sends a Discovery Response, as described later.</li>
          <li>Synchronization Initiator: an ASA that starts synchronization
          by sending a request message referring to a specific synchronization
          objective.</li>
          <li>Synchronization Responder: a peer ASA which responds with the
          value of a synchronization objective.</li>
          <li>Negotiation Initiator: an ASA that starts
          negotiation by sending a request message referring to a specific
          negotiation objective.</li>
          <li>Negotiation Counterpart: a peer with which the Negotiation
          Initiator negotiates a specific negotiation objective.</li>
          <li>GRASP Instance: This refers to an instantiation of a GRASP protocol engine, likely including
          multiple threads or processes as well as dynamic data structures such as a discovery cache, running in
          a given security environment on a single device. </li>
          <li>GRASP Core: This refers to the code and shared data structures of a GRASP instance, which will
          communicate with individual ASAs via a suitable Application Programming Interface (API).</li>
          <li>Interface or GRASP Interface: Unless otherwise stated, these refer to a network
          interface - which might be physical or virtual - that a specific instance of
          GRASP is currently using. A device might have other interfaces that are not
          used by GRASP and which are outside the scope of the autonomic network.</li>
        </ul>
      </section>
      <section anchor="hilev" numbered="true" toc="default">
        <name>High Level Deployment Model</name>
        <t>A GRASP implementation will be part of the Autonomic Networking Infrastructure (ANI)
      in an autonomic node, which must also provide an appropriate security environment.
      In accordance with <xref target="I-D.ietf-anima-reference-model" format="default"/>, this SHOULD be the
      Autonomic Control Plane (ACP) <xref target="I-D.ietf-anima-autonomic-control-plane" format="default"/>.
      As a result, all autonomic nodes in the ACP are able to trust each other.
      It is expected that GRASP will access the ACP by using a typical socket programming interface
      and the ACP will make available only network interfaces within the autonomic network.
      If there is no ACP, the considerations described in <xref target="reqsec" format="default"/> apply. </t>
        <t>
      There will also be one or more Autonomic Service Agents (ASAs). In the minimal case 
      of a single-purpose device, these components might be fully integrated with GRASP
      and the ACP. A more common model is expected to be a multi-purpose device capable of containing
      several ASAs, such as a router or large switch. In this case it is expected that the ACP, GRASP and the ASAs will
      be implemented as separate processes, which are able to support
      asynchronous and simultaneous operations, for example by multi-threading.</t>
        <t>In some scenarios, a limited negotiation model might be deployed based on a limited
      trust relationship such as that between two administrative domains. ASAs might then
      exchange limited information and negotiate some particular configurations.</t>
        <t>GRASP is explicitly designed to operate within a single addressing realm.
      Its discovery and flooding mechanisms do not support autonomic operations that
      cross any form of address translator or upper layer proxy.</t>
        <t>A suitable Application Programming Interface (API) will be needed
      between GRASP and the ASAs. In some implementations, ASAs would run in user
      space with a GRASP library providing the API, and this library would in turn
      communicate via system calls with core GRASP functions.
      Details of the API are out of scope for the present document.
      For further details of possible deployment models, see
      <xref target="I-D.ietf-anima-reference-model" format="default"/>.
        </t>
        <t>An instance of GRASP must be aware of the network interfaces it will use, and of the
      appropriate global-scope
      and link-local addresses. In the presence of the ACP, such information will be available from
      the adjacency table discussed in <xref target="I-D.ietf-anima-reference-model" format="default"/>.
      In other cases, GRASP must determine such information for itself. Details depend on the
      device and operating system. In the rest of this document, the terms 'interfaces'
      or 'GRASP interfaces'
      refers only to the set of network interfaces that a specific instance
      of GRASP is currently using. </t>
        <t>Because GRASP needs to work with very high reliability, especially during bootstrapping
      and during fault conditions, it is essential that every implementation continues to
      operate in adverse conditions. For example, discovery failures, or any kind of socket
      exception at any time, must not cause irrecoverable failures in GRASP itself, and must
      return suitable error codes through the API so that ASAs can also recover.
        </t>
        <t>GRASP must not depend upon non-volatile data storage. All run time error
      conditions, and events such as address renumbering, network interface failures,
      and CPU sleep/wake cycles, must be handled in such a way that GRASP will still
      operate correctly and securely (<xref target="reqsec" format="default"/>) afterwards.</t>
        <t>An autonomic node will normally run a single instance of GRASP, used by multiple ASAs.
      Possible exceptions are mentioned below.
        </t>
      </section>
      <section anchor="highlevel" numbered="true" toc="default">
        <name>High Level Design</name>
        <t>This section describes the behavior model and general design of
        GRASP, supporting discovery, synchronization and negotiation, to
        act as a platform for different technical objectives.</t>
        <ul spacing="normal">
          <li>
            <t>A generic platform:</t>
            <t>
            The protocol design is generic and independent of the synchronization or 
            negotiation contents. The technical contents will vary according to the
            various technical objectives and the different pairs of
            counterparts.</t>
            
          </li>
          <li>
            <t>Normally, a single main instance of the GRASP protocol engine will exist in an autonomic
            node, and each ASA will run as an independent asynchronous process. However, scenarios
            where multiple instances of GRASP run in a single node, perhaps with different security
            properties, are possible (<xref target="secinst" format="default"/>). In this case, each instance MUST
            listen independently for GRASP link-local multicasts,
			      and all instances MUST be woken by each such multicast, in order for
			      discovery and flooding to work correctly.
            </t>
            
          </li>
          <li>
            <t>Security infrastructure:</t>
            <t>
            As noted above, the protocol itself has no built-in security functionality,
            and relies on a separate secure infrastructure.</t>
            
          </li>
          <li>
            <t>Discovery, synchronization and negotiation are designed together:</t>
            <t>
            The discovery method and the synchronization and negotiation methods
            are designed in the same way and can be combined when this is
            useful, allowing a rapid mode of operation described in <xref target="discmech" format="default"/>.
            These processes can also be performed independently when appropriate.
            </t>
            <ul spacing="normal">
              <li>Thus, for some objectives, especially those concerned with application layer
              services, another discovery mechanism such as the future DNS Service
              Discovery <xref target="RFC7558" format="default"/> MAY be used.
              The choice is left to the designers of individual ASAs.</li>
            </ul>
            
          </li>
          <li>
            <t>A uniform pattern for technical objectives:</t>
            <t>
            The synchronization and negotiation objectives are defined
            according to a uniform pattern. The values that they contain
            could be carried either in a simple binary format or in a
            complex object format. The basic protocol design uses the Concise
            Binary Object Representation (CBOR) <xref target="RFC7049" format="default"/>, 
            which is readily extensible for unknown future requirements. </t>
            
          </li>
          <li>
            <t>A flexible model for synchronization:</t>
            <t>
            GRASP supports synchronization between two nodes, which could be used
            repeatedly to perform synchronization among a small number of nodes.
            It also supports an unsolicited flooding mode when large groups of nodes,
            possibly including all autonomic nodes, need data for the same
            technical objective.
                        
            </t>
            <ul spacing="normal">
              <li>There may be some network parameters for which a more traditional flooding
              mechanism such as DNCP <xref target="RFC7787" format="default"/>
              is considered more appropriate. GRASP can coexist with DNCP.
              </li>
            </ul>
            
          </li>
          <li>
            <t>A simple initiator/responder model for negotiation:</t>
            <t>
            Multi-party negotiations are very complicated to model and cannot
            readily be guaranteed to converge. GRASP uses a simple bilateral model 
            and can support multi-party negotiations by indirect steps.
            </t>
            
          </li>
          <li>
            <t>Organizing of synchronization or negotiation content:</t>
            <t>
            The technical content transmitted by GRASP will be
            organized according to the relevant function or service. The
            objectives for different functions or services are kept
            separate, because they may be negotiated or synchronized with different 
            counterparts or have different response times. Thus a normal arrangement
            would be a single ASA managing a small set of closely related objectives,
            with a version of that ASA in each relevant autonomic node. Further
            discussion of this aspect is out of scope for the current document.
            </t>
            
          </li>
          <li>
            <t>Requests and responses in negotiation procedures:</t>
            <t>
            The initiator can negotiate a specific negotiation objective with relevant
            counterpart ASAs. It can request relevant information from a counterpart so that it
            can coordinate its local configuration. It can request the counterpart to make
            a matching configuration. It can request simulation or forecast results by sending
            some dry run conditions.
            </t>
            <t>Beyond the traditional yes/no answer, the
            responder can reply with a suggested alternative value for the objective
            concerned. This would start a bi-directional negotiation
            ending in a compromise between the two ASAs.</t>
            
          </li>
          <li>
            <t>Convergence of negotiation procedures:</t>
            <t>
            To enable convergence, when a responder suggests a new value or
            condition in a negotiation step reply, it should be as close as possible
            to the original request or previous suggestion. The suggested value of
            later negotiation steps should be chosen between the suggested values from
            the previous two steps. GRASP provides mechanisms to guarantee convergence
            (or failure) in a small number of steps, namely a timeout and a maximum number
            of iterations.
            </t>
            
          </li>
          <li>
            <t>Extensibility:</t>
            <t>
            GRASP intentionally does not have a version number, and can be extended by adding new
            message types and options. The Invalid Message (M_INVALID) will be used to signal
            that an implementation does not recognize a message or option sent by another
            implementation. In normal use, new semantics will be added
            by defining new synchronization or negotiation objectives.
            </t>
          </li>
        </ul>
      </section>
      <section numbered="true" toc="default">
        <name>Quick Operating Overview</name>
        <t>An instance of GRASP is expected to run as a separate core module,
        providing an API (such as <xref target="I-D.ietf-anima-grasp-api" format="default"/>) to interface to
        various ASAs.
        These ASAs may operate without special privilege, unless they need it for
        other reasons (such as configuring IP addresses or manipulating routing
        tables).
        </t>
        <t>
        The GRASP mechanisms used by the ASA are built around GRASP objectives
        defined as data structures
        containing administrative information such as the objective's unique
        name, and its current value.  The format and size of the value is
        not restricted by the protocol, except that it must be possible to
        serialize it for transmission in CBOR, which is no
        restriction at all in practice.
        </t>
        <t>
       GRASP provides the following mechanisms:
        </t>
        <ul spacing="normal">
          <li>A discovery mechanism (M_DISCOVERY, M_RESPONSE), by which an ASA can
         discover other ASAs supporting a given objective.
        </li>
          <li>
         A negotiation request mechanism (M_REQ_NEG), by which an ASA can start
         negotiation of an objective with a counterpart ASA. Once a negotiation has
         started, the process is symmetrical, and there is a negotiation step message
         (M_NEGOTIATE) for each ASA to use in turn. Two other functions support negotiating
         steps (M_WAIT, M_END).
        </li>
          <li>
         A synchronization mechanism (M_REQ_SYN), by which an ASA can request the
         current value of an objective from a counterpart ASA.  With this,
         there is a corresponding response function (M_SYNCH) for an ASA that
         wishes to respond to synchronization requests.
        </li>
          <li>
        A flood mechanism (M_FLOOD), by which an ASA can cause the current value of
        an objective to be flooded throughout the autonomic network so that any ASA can
        receive it. One application of this is to act as an announcement, avoiding the need for
        discovery of a widely applicable objective.</li>
        </ul>
        <t>Some example messages and simple message flows are provided in <xref target="examples" format="default"/>.</t>
      </section>
      <section numbered="true" toc="default">
        <name>GRASP Protocol Basic Properties and Mechanisms</name>
        <section anchor="reqsec" numbered="true" toc="default">
          <name>Required External Security Mechanism</name>
          <t>GRASP does not specify transport security because it is meant to be adapted to
         different environments. Every solution adopting GRASP MUST specify a security and transport substrate
	 used by GRASP in that solution.</t>
          <t>The substrate MUST enforce sending and receiving GRASP messages only between members of a mutually trusted
	 group running GRASP. Each group member is an instance of GRASP. The group members are nodes of a
	 connected graph. The group and graph is created by the security and transport substrate and called the GRASP domain.
	 The substrate must support unicast messages between any group members and (link-local) multicast
	 messages between adjacent group members. It must deny messages between group members and non group
	 members. With this model, security is provided by enforcing group membership, but any member of the
         trusted group can attack the entire network until revoked.</t>
          <t> Substrates MUST use cryptographic member authentication and message integrity for GRASP messages.
	 This can be end-to-end or hop-by-hop across the domain. The security and transport substrate MUST provide mechanisms
	 to remove untrusted members from the group.</t>
          <t>If the substrate does not mandate and enforce GRASP message encryption then any service
	 using GRASP in such a solution MUST provide protection and encryption for message elements whose
	 exposure could constitute an attack vector.</t>
          <t>The security and transport substrate for GRASP in the ANI is the ACP. Unless otherwise noted, we assume this
	 security and transport substrate in the remainder of this document. The ACP does mandate the use of encryption;
	 therefore GRASP in the ANI can rely on GRASP message being encrypted. The GRASP domain is the ACP: all
	 nodes in an autonomic domain connected by encrypted virtual links formed by the ACP. The ACP uses
	 hop-by-hop security (authentication/encryption) of messages. Removal of nodes relies on standard
	 PKI certificate revocation or expiry of sufficiently short lived certificates. Refer to 
         <xref target="I-D.ietf-anima-autonomic-control-plane" format="default"/> for more details.</t>
          <t>As mentioned in <xref target="highlevel" format="default"/>, some GRASP operations might be
         performed across an administrative domain boundary by mutual agreement, without the
         benefit of an ACP. Such operations
         MUST be confined to a separate instance of GRASP with its own copy of all GRASP
         data structures running across a separate GRASP domain with a security and transport substrate. 
         In the most simple case, each point-to-point interdomain GRASP peering could be a
         separate domain and the security and transport substrate could be built using transport or network layer
         security protocols. This is subject to future specifications. </t>
          <!-- TLS <xref target="RFC5246"/> and DTLS <xref target="RFC6347"/> based on a Public Key Infrastructure (PKI)
         <xref target="RFC5280"/> are RECOMMENDED for this purpose.-->

         <t>An exception to the requirements for the security and transport substrate exists 
         for highly constrained subsets of GRASP meant to support the establishment of a security and transport substrate,
         described in the following section.</t>
        </section>
        <section anchor="secinst" numbered="true" toc="default">
          <name>Discovery Unsolicited Link-Local (DULL) GRASP</name>
          <t>Some services may need to use insecure GRASP discovery, response
         and flood messages without being able to use pre-existing security associations, for example
	       as part of discovery for establishing security associations such as a security substrate for
	       GRASP.</t>
          <t>Such operations being intrinsically insecure, they need to be confined to link-local
         use to minimize the risk of malicious actions. Possible examples
         include discovery of candidate ACP neighbors 
         <xref target="I-D.ietf-anima-autonomic-control-plane" format="default"/>, discovery of bootstrap
         proxies <xref target="I-D.ietf-anima-bootstrapping-keyinfra" format="default"/> or perhaps
         initialization services in networks using GRASP without being fully autonomic
         (e.g., no ACP).
         Such usage MUST be limited to link-local operations on a single interface and MUST be confined
         to a separate insecure instance of GRASP with its own copy of all GRASP
         data structures. This instance is nicknamed DULL - Discovery Unsolicited Link-Local.</t>
          <t>The detailed rules for the DULL instance of GRASP are as follows:
          </t>
          <ul spacing="normal">
            <li>An initiator MAY send Discovery or Flood Synchronization link-local
         multicast messages which MUST have a loop count of 1, to prevent
         off-link operations.
         Other unsolicited GRASP message types MUST NOT be sent.</li>
            <li>A responder MUST silently discard any message whose loop count is not 1.</li>
            <li>A responder MUST silently discard any message referring to a GRASP Objective that is
         not directly part of a service that requires this insecure mode.</li>
            <li>A responder MUST NOT relay any multicast messages.</li>
            <li>A Discovery Response MUST indicate a link-local address.</li>
            <li>A Discovery Response MUST NOT include a Divert option.</li>
            <li>A node MUST silently discard any message whose source address is not link-local.</li>
          </ul>
          <t>To minimize traffic possibly observed by third parties,
         GRASP traffic SHOULD be minimized by using only Flood Synchronization
         to announce objectives and their associated locators, rather than by using Discovery
         and Response. Further details are out of scope for this document</t>
        </section>
        <!-- <section anchor="secinst-sonn" title="Secure Only Neighbor Negotiation">
         
         <t>Some services might use insecure on-link operations as in DULL,
         but also use unicast synchronization or negotiation operations protected by TLS.
         A separate instance of GRASP is used, with its own copy of all GRASP data structures.
         This instance is nicknamed SONN - Secure Only Neighbor Negotiation.</t>
         <t>
         The detailed rules for the SONN instance of GRASP are as follows:
         <list style="symbols">
         <t>All types of GRASP message are permitted.</t>
         <t>An initiator MUST send any Discovery or Flood Synchronization link-local
         multicast messages with a loop count of 1.</t>
         <t>A responder MUST silently discard any Discovery or Flood Synchronization message whose loop count is not 1.</t>
         <t>A responder MUST silently discard any message referring to a GRASP Objective that is
         not directly part of the service concerned.</t>
         <t>A responder MUST NOT relay any multicast messages.</t>
         <t>A Discovery Response MUST indicate a link-local address.</t>
         <t>A Discovery Response MUST NOT include a Divert option.</t>
         <t>A node MUST silently discard any message whose source address is not link-local.</t>
         </list></t>
         <t>Further details are out of scope for this document.</t>
         </section> -->
 
        
        <section anchor="trans" numbered="true" toc="default">
          <name>Transport Layer Usage</name>
          <t>All GRASP messages, after they are serialized as a CBOR byte string, are transmitted
        as such directly over the transport protocol in use. The transport protocol(s) for a GRASP
        domain are specified by the security and transport substrate as introduced in <xref target="reqsec" format="default"/>.</t>
          <t>GRASP discovery and flooding messages are designed for GRASP domain wide flooding
        through hop-by-hop link-local multicast forwarding between adjacent GRASP nodes. The
        GRASP security and transport substrate needs to specify how these link local multicasts
        are transported. This can be unreliable transport (UDP) but it SHOULD be reliable
        transport (e.g., TCP).</t>
          <t>If the substrate specifies an unreliable transport such as UDP for discovery and flooding messages,
        then it MUST NOT use IP fragmentation because of its loss characteristic, especially
        in multi-hop flooding. GRASP MUST then enforce at the user API level a limit to the size
        of discovery and flooding messages, so that no fragmentation can occur. For IPv6 transport this
        means that those messages must be at most 1280 bytes sized IPv6 packets (unless there is a known
        larger minimum link MTU across the whole GRASP domain).</t>
          <t>All other GRASP messages are unicast beteween group members of the GRASP domain. These
        MUST use a reliable transport protocol because GRASP itself does not provide for error detection,
        retransmission or flow control. Unless otherwise specified by the security and transport
        substrate, TCP MUST be used.</t>
          <t>The security and transport substrate for GRASP in the ANI is the ACP. Unless otherwise noted,
        we assume this security and transport substrate in the remainder of this document when describing
        GRASPs message transport. In the ACP, TCP is used for GRASP unicast messages. GRASP discovery and
        flooding messages also use TCP: These link-local messages are forwarded by replicating them to
        all adjacent GRASP nodes on the link via TCP connections to those adjacent GRASP nodes. Because
        of this, GRASP in the ANI has no limitations on the size of discovery and flooding messages with
        respect to fragmentation issues. UDP is used in the ANI with GRASP only with DULL when the ACP is built
        to discover ACP/GRASP neighbors on links.</t>
          <!-- <t>Nevertheless, when running within a secure ACP on reliable infrastructure,
        UDP MAY be used for unicast messages not exceeding the minimum IPv6 path MTU;
        however, TCP MUST be used for longer messages. In other words, IPv6 fragmentation
        is avoided. If a node receives a UDP message but the reply is too long, it
        MUST open a TCP connection to the peer for the reply. Note that when
        the network is under heavy load or in a fault condition, UDP might become
        unreliable. Since this is when autonomic functions are most necessary,
        automatic fallback to TCP MUST be implemented. The simplest implementation
        is therefore to use only TCP.</t> -->
        
        <t>For link-local UDP multicast, the GRASP protocol listens to the well-known
        GRASP Listen Port (<xref target="Constants" format="default"/>). Transport connections for Discovery
        and Flooding on relay nodes must terminate in GRASP instances (eg: GRASP ASAs) so
        that link-local multicast, hop-by-hop flooding of M_DISCOVERY and M_FLOOD and hop-by-hop forwarding
        of M_RESPONSE and caching of those responses along the path work correctly.</t>
          <t>Unicast transport connections used for synchronization and negotiation can terminate
        directly in ASAs that implement objectives and therefore this traffic does not need to
        pass through GRASP instances. For this, the ASA listens on its own dynamically assigned ports,
        which are communicated to its peers during discovery. Alternatively, the GRASP instance
        can also terminate the unicast transport connections and pass the traffic from/to the 
        ASA if that is preferrable in some implementation (eg: to better decouple ASAs from
        network connections).</t>
        </section>
        <section anchor="discmech" numbered="true" toc="default">
          <name>Discovery Mechanism and Procedures</name>
          <section numbered="true" toc="default">
            <name>Separated discovery and negotiation mechanisms</name>
            <t>Although discovery and negotiation or synchronization are defined
                  together in GRASP, they are separate mechanisms. The discovery
                  process could run independently from the negotiation or synchronization
                  process. Upon receiving a Discovery (<xref target="DiscoveryMessage" format="default"/>)
                  message, the
                  recipient node should return a response message in which it either
                  indicates itself as a discovery responder or diverts the
                  initiator towards another more suitable ASA. However, this
                  response may be delayed if the recipient needs to relay
                  the discovery onwards, as described below.</t>
            <t>The discovery action (M_DISCOVERY) will normally be followed by
                  a negotiation (M_REQ_NEG) or synchronization (M_REQ_SYN) action. The
                  discovery results could be utilized by the negotiation
                  protocol to decide which ASA the initiator will negotiate
                  with.</t>
            <t>The initiator of a discovery action for a given objective need not
                  be capable of responding to that objective as a Negotiation Counterpart, as a
                  Synchronization Responder or as source for flooding. For example, an ASA might perform
                  discovery even if it only wishes to act a Synchronization Initiator or Negotiation Initiator.
                  Such an ASA does not itself need to respond to discovery messages.</t>
            <t>It is also entirely possible to use GRASP discovery without any subsequent
                  negotiation or synchronization action. In this case, the discovered objective
                  is simply used as a name during the discovery process and any subsequent
                  operations between the peers are outside the scope of GRASP.</t>
          </section>
          <section anchor="discovw" numbered="true" toc="default">
            <name>Discovery Overview</name>
            <t>A complete discovery process will start with a multicast (of M_DISCOVERY) on the 
                local link. On-link neighbors supporting the discovery objective will
                respond directly (with M_RESPONSE). A neighbor with multiple interfaces may respond
                with a cached discovery response. If it has no cached response, it will relay the 
                discovery on its other GRASP interfaces<!--, for example reaching a higher-level gateway
                in a hierarchical network-->. If a node receiving the relayed discovery
                supports the discovery objective, it will respond to the relayed discovery.
                If it has a cached response, it will respond with that. 
                If not, it will repeat the discovery process, which thereby becomes iterative.
                The loop count and timeout will ensure that the process ends. Further details
                are given below.
            </t>
            <t>A Discovery message MAY be sent unicast to a peer node,
                which SHOULD then proceed exactly as if the message had been multicast,
                except that when TCP is used, the response will be
                on the same socket as the query. However,
                this mode does not guarantee successful discovery in the general case.
            </t>
          </section>
          <section anchor="discproc" numbered="true" toc="default">
            <name>Discovery Procedures</name>
            <t>Discovery starts as an on-link operation. The Divert option
                  can tell the discovery initiator to contact an off-link
                  ASA for that discovery objective. If the security and transport substrate
                  of the GRASP domain (see <xref target="trans" format="default"/>) uses UDP link-local multicast
                  then the discovery initiator sends these to the ALL_GRASP_NEIGHBORS link-local
                  multicast address (<xref target="Constants" format="default"/>) and and all GRASP nodes need
                  to listen to this address to act as discovery responder.
                  Because this port
                  is unique in a device, this is a function of the GRASP instance
                  and not of an individual ASA. As a result, each ASA will need to
                  register the objectives that it supports with the local GRASP instance.</t>
            <t>If an ASA in a neighbor device supports the requested discovery objective,
                  the device SHOULD respond to the link-local multicast with a unicast Discovery Response
                  message (<xref target="ResponseMessage" format="default"/>) with locator option(s), unless it is
                  temporarily unavailable. Otherwise, if the neighbor has cached information
                  about an ASA that supports the requested discovery objective (usually
                  because it discovered the same objective before), it SHOULD
                  respond with a Discovery Response message with a Divert option pointing
                  to the appropriate Discovery Responder. However, it SHOULD NOT respond
                  with a cached response on an interface if it learnt that information from
                  the same interface, because the peer in question will answer directly if still
                  operational.</t>
            <t>If a device has no information about the requested discovery objective,
                  and is not acting as a discovery relay (see below) it MUST silently
                  discard the Discovery message.</t>
            <t>The discovery initiator MUST set a reasonable timeout on the
                  discovery process. A suggested value is 100 milliseconds multiplied by the loop count
                  embedded in the objective.</t>
            <t>If no discovery response is received within the timeout,
                  <!-- a reasonable timeout
                  (default GRASP_DEF_TIMEOUT milliseconds, <xref target="Constants"/>),-->
                  the Discovery message MAY be repeated, with a newly generated
                  Session ID (<xref target="SessionID" format="default"/>). An exponential backoff SHOULD be used
                  for subsequent repetitions, to limit the load during busy periods. The
                  details of the backoff algorithm will depend on the use case for the
                  objective concerned but MUST be consistent with the recommendations
                  in <xref target="RFC8085" format="default"/> for low data-volume multicast.
                  Frequent repetition might be symptomatic of a denial of service attack.</t>
            <t>After a GRASP device successfully discovers a locator for a Discovery Responder
                  supporting a specific objective, it SHOULD cache this information, including the interface
                  index <xref target="RFC3493" format="default"/> via which it was discovered. This cache record MAY be used for future
                  negotiation or synchronization, and the locator SHOULD be passed on when appropriate
                  as a Divert option to another Discovery Initiator.</t>
            <t>The cache mechanism MUST include a lifetime for each entry. The
                  lifetime is derived from a time-to-live (ttl) parameter in each
                  Discovery Response message.
                  Cached entries MUST be ignored or deleted after their lifetime expires.
                  In some environments, unplanned address renumbering might occur.
                  In such cases, the lifetime SHOULD be short compared to
                  the typical address lifetime<!-- and a mechanism to flush the
                  discovery cache MUST be implemented-->. The discovery mechanism
                  needs to track the node's current address to ensure that Discovery
                  Responses always indicate the correct address.</t>
            <t>If multiple Discovery Responders are found for the same objective, they
                  SHOULD all be cached, unless this creates a resource shortage. The method
                  of choosing between multiple responders is an implementation choice.
                  This choice MUST be available to each ASA but the GRASP implementation
                  SHOULD provide a default choice.</t>
            <t>Because Discovery Responders will be cached in a finite cache, they might
                  be deleted at any time. In this case, discovery will need to be repeated. If an
                  ASA exits for any reason, its locator might still be cached for some time,
                  and attempts to connect to it will fail. ASAs need to be robust in these
                  circumstances. </t>
          </section>
          <section numbered="true" toc="default">
            <name>Discovery Relaying</name>
            <t>A GRASP instance with multiple link-layer interfaces (typically running in a router) MUST
                  support discovery on all GRASP interfaces. We refer to this as a 'relaying instance'.</t>
            <t>DULL Instances (<xref target="secinst" format="default"/>) are
                  always single-interface instances and therefore MUST NOT perform discovery relaying.</t>
            <t>If a relaying instance receives a Discovery message
                  on a given interface for a specific objective that it does not support and for
                  which it has not previously cached a Discovery Responder, it MUST relay
                  the query by re-issuing a new Discovery message as a link-local multicast on its other
                  GRASP interfaces.</t>
            <t> The relayed discovery message MUST have the same Session ID and Initiator field
                  as the incoming (see <xref target="DiscoveryMessage" format="default"/>). The Initiator IP address field is only
                  used to allow for disambiguation of the Session ID and is never used to address Response packets.
                  Response packets are sent back to the relaying instance, not the original initiator.</t>
            <t>The M_DISCOVERY message does not encode the transport address of the originator or
                  relay. Response packets must therefore be sent to the transport layer address of the connection
                  on which the M_DISCOVERY message was received. If the M_DISCOVERY was relayed via a reliable 
                  hop-by-hop transport connection, the response is simply sent back via the same connection.</t>
            <t>If the M_DISCOVERY was relayed via link-local (eg: UDP) multicast, the response is sent
                  back via a reliable hop-by-hop transport connection with the same port number as
                  the source port of the link-local multicast. Therefore, if link-local multicast is
                  used and M_RESPONSE messages are required (which is the case in almost all GRASP instances
                  except for the limited use of DULL instances in the ANI), GRASP needs to be able to bind to one
                  port number on UDP from which to originate the link-local multicast M_DISCOVERY messages
                  and the same port number on the reliable hop-by-hop transport (eg: TCP by default)
                  to be able to respond to transport connections from responders that want to send
                  M_RESPONSE messages back. Note that this port does not need to be the GRASP_LISTEN_PORT.</t>
            <t>The relaying instance MUST decrement the loop count within the objective, and 
                  MUST NOT relay the Discovery message if the result is zero.
                  Also, it MUST limit the total rate at which it relays discovery messages
                  to a reasonable value, in order to mitigate possible denial of service attacks.
                  For example, the rate limit could be set to a small multiple of the observed
                  rate of discovery messages during normal operation.
                  The relaying instance MUST cache the Session ID value and initiator address of each
                  relayed Discovery message until any Discovery Responses have arrived or 
                  the discovery process has timed out.
                  To prevent loops, it MUST NOT relay a Discovery message
                  which carries a given cached Session ID and initiator address more than once.
                  These precautions avoid discovery loops and mitigate potential overload.</t>
            <t>Since the relay device is unaware of the timeout set by the original
                  initiator it SHOULD set a suitable timeout for the relayed discovery. <!-- significantly less than GRASP_DEF_TIMEOUT
                  milliseconds (<xref target="Constants"/>).-->
                  A suggested value is 100 milliseconds multiplied by the remaining loop count.</t>
            <t>The discovery results received by the relaying instance MUST in turn be
                  sent as a Discovery Response message to the Discovery message that caused
                  the relay action.</t>
          </section>
          <section anchor="rapid" numbered="true" toc="default">
            <name>Rapid Mode (Discovery with Negotiation or Synchronization )</name>
            <t>A Discovery message MAY include an
                  Objective option. This allows a rapid mode of negotiation
                  (<xref target="rapidneg" format="default"/>) or
                  synchronization (<xref target="rapidsynch" format="default"/>).
                  Rapid mode is currently limited to a single objective
                  for simplicity of design and implementation. A possible future extension
                  is to allow multiple objectives in rapid mode for greater efficiency.
            </t>
          </section>
        </section>
        <section anchor="negproc" numbered="true" toc="default">
          <name>Negotiation Procedures</name>
          <t>A negotiation initiator opens a transport connection to a
          counterpart ASA using the address, protocol and port obtained during discovery.
          It then sends a negotiation request (using M_REQ_NEG) to the counterpart,
          including a specific negotiation objective. It may request the negotiation
          counterpart to make a specific configuration. Alternatively, it may
          request a certain simulation or forecast result by sending a dry run configuration.
          The details, including the distinction between a dry run and a live
          configuration change, will be defined separately for each type of negotiation
          objective. Any state associated with a dry run operation,
          such as temporarily reserving a resource for subsequent use in a live
          run, is entirely a matter for the designer of the ASA concerned.</t>
          <t>Each negotiation session as a whole is subject to a timeout
          (default GRASP_DEF_TIMEOUT milliseconds, <xref target="Constants" format="default"/>),
          initialised when the request is sent (see <xref target="RequestMessage" format="default"/>).
          If no reply message of any kind is received within the timeout,
          the negotiation request MAY be repeated, with a newly generated
          Session ID (<xref target="SessionID" format="default"/>). An exponential backoff SHOULD be used
          for subsequent repetitions. The
          details of the backoff algorithm will depend on the use case for the
          objective concerned.</t>
          
          <t>If the counterpart can immediately apply the requested
          configuration, it will give an immediate positive (O_ACCEPT) answer (using M_END).
          This will end the negotiation phase immediately. Otherwise, it will
          negotiate (using M_NEGOTIATE). It will reply with a proposed alternative configuration
          that it can apply (typically, a configuration that uses fewer resources
          than requested by the negotiation initiator). This will start a
          bi-directional negotiation (using M_NEGOTIATE) to reach a compromise between the two ASAs.</t>
          <t>The negotiation procedure is ended when one of the negotiation
          peers sends a Negotiation Ending (M_END) message, which contains an accept (O_ACCEPT)
          or decline (O_DECLINE) option and does not need a response from the negotiation
          peer. Negotiation may also end in failure (equivalent to a decline)
          if a timeout is exceeded or a loop count is exceeded. When the procedure
          ends for whatever reason, the transport connection SHOULD be closed.
          A transport session failure is treated as a negotiation failure.</t>
          <t>A negotiation procedure concerns one objective and one
          counterpart. Both the initiator and the counterpart may take part in
          simultaneous negotiations with various other ASAs, or in
          simultaneous negotiations about different objectives. Thus, GRASP is
          expected to be used in a multi-threaded mode or its logical equivalent. Certain negotiation
          objectives may have restrictions on multi-threading, for example to
          avoid over-allocating resources. </t>
          <t>Some configuration actions, for example wavelength switching
          in optical networks, might take considerable time to execute. The ASA
          concerned needs to allow for this by design, but GRASP does allow for
          a peer to insert latency in a negotiation process if necessary
          (<xref target="ConfirmWaitingMessage" format="default"/>, M_WAIT).</t>
          <section anchor="rapidneg" numbered="true" toc="default">
            <name>Rapid Mode (Discovery/Negotiation Linkage)</name>
            <t>A Discovery message MAY include a Negotiation
             Objective option. In this case it is as if the initiator sent the sequence
             M_DISCOVERY, immediately followed by M_REQ_NEG.
             This has implications for the construction of the GRASP core, as it must carefully
             pass the contents of the Negotiation Objective option to the ASA so that it
             may evaluate the objective directly. When a Negotiation Objective option is
             present the ASA replies with an M_NEGOTIATE message (or M_END with O_ACCEPT if it is
             immediately satisfied with the proposal), rather than with an M_RESPONSE.
             However, if the recipient node does not support rapid mode, discovery will
             continue normally.</t>
            <t>It is possible that a Discovery Response will arrive from a responder that
             does not support rapid mode, before such a Negotiation message arrives.
             In this case, rapid mode will not occur.</t>
            <t>This rapid mode could reduce the interactions between
             nodes so that a higher efficiency could be achieved. However, a network in which some
             nodes support rapid mode and others do not will have complex timing-dependent behaviors.
             Therefore, the rapid negotiation function SHOULD be disabled by default.
            </t>
          </section>
        </section>
        <section anchor="synchproc" numbered="true" toc="default">
          <name>Synchronization and Flooding Procedures</name>
          <section anchor="synch" numbered="true" toc="default">
            <name>Unicast Synchronization</name>
            <t>A synchronization initiator opens a transport connection to a
          counterpart ASA using the address, protocol and port obtained during discovery.
          It then sends a synchronization request (using M_REQ_SYN) to the
          counterpart, including a specific synchronization objective.
          The counterpart responds with a Synchronization message (M_SYNCH, <xref target="SynchMessage" format="default"/>)
          containing the current value of the requested synchronization
          objective. No further messages are needed and the transport
          connection SHOULD be closed. A transport session failure is treated
          as a synchronization failure.</t>
            <t>If no reply message of any kind is received within a given timeout
          (default GRASP_DEF_TIMEOUT milliseconds, <xref target="Constants" format="default"/>),
          the synchronization request MAY be repeated, with a newly generated
          Session ID (<xref target="SessionID" format="default"/>). An exponential backoff SHOULD be used
          for subsequent repetitions. The
          details of the backoff algorithm will depend on the use case for the
          objective concerned.</t>
          </section>
          <section anchor="flooding" numbered="true" toc="default">
            <name>Flooding</name>
            <t>In the case just described, the message exchange is unicast and
          concerns only one synchronization objective. For large groups of nodes
          requiring the same data, synchronization flooding is available. For this, 
          a flooding initiator MAY send an unsolicited Flood Synchronization message containing
          one or more Synchronization Objective option(s), if and only if the specification 
          of those objectives permits it. This is sent as a multicast message to the 
          ALL_GRASP_NEIGHBORS multicast address (<xref target="Constants" format="default"/>).</t>
            <t>Receiving flood multicasts is a function of the GRASP core, 
          as in the case of discovery multicasts (<xref target="discproc" format="default"/>).</t>
            <t>To ensure that flooding does not result in a loop, the originator of the Flood Synchronization message
          MUST set the loop count in the objectives to a suitable value (the default is GRASP_DEF_LOOPCT).
          Also, a suitable mechanism is needed
          to avoid excessive multicast traffic. This mechanism MUST be defined as part of the
          specification of the synchronization objective(s) concerned. It might be a simple rate
          limit or a more complex mechanism such as the Trickle algorithm <xref target="RFC6206" format="default"/>.</t>
            <t>A GRASP device with multiple link-layer interfaces (typically a router) MUST
          support synchronization flooding on all GRASP interfaces. If it receives a multicast
          Flood Synchronization message on a given interface, it MUST relay
          it by re-issuing a Flood Synchronization message as a link-local multicast
          on its other GRASP interfaces.
          The relayed message MUST have the same Session ID as the incoming
          message and MUST be tagged with the IP address of its original initiator. </t>
            <t>Link-layer Flooding is supported by GRASP by setting the loop count to 1,
          and sending with a link-local source address. Floods with link-local source addresses
          and a loop count other than 1 are invalid, and such messages MUST be discarded.</t>
            <t>The relaying device MUST decrement the loop count within the first objective, and  
          MUST NOT relay the Flood Synchronization message if the result is zero.
          Also, it MUST limit the total rate at which it relays Flood Synchronization messages
          to a reasonable value, in order to mitigate possible denial of service attacks.
          For example, the rate limit could be set to a small multiple of the observed
          rate of flood messages during normal operation.
          The relaying device MUST cache the Session ID value and initiator address of each relayed
          Flood Synchronization message for a time not less than twice GRASP_DEF_TIMEOUT milliseconds.
          To prevent loops, it MUST NOT relay a Flood Synchronization message
          which carries a given cached Session ID and initiator address more than once.
          These precautions avoid synchronization loops and mitigate potential overload.</t>
            <t>Note that this mechanism is unreliable in the case of sleeping nodes,
          or new nodes that join the network, or nodes that rejoin the network
          after a fault. An ASA that initiates a flood SHOULD repeat the flood
          at a suitable frequency, which MUST be consistent with the recommendations
          in <xref target="RFC8085" format="default"/> for low data-volume multicast.
          The ASA SHOULD also act as a synchronization responder for
          the objective(s) concerned. Thus nodes that require an objective subject to
          flooding can either wait for the next flood or request unicast synchronization
          for that objective. </t>
            <t>The multicast messages for synchronization flooding are subject to the security
          rules in <xref target="reqsec" format="default"/>. In practice this means that they MUST NOT be transmitted
          and MUST be ignored on receipt unless there is an operational ACP or equivalent strong
          security in place. However, because
          of the security weakness of link-local multicast (<xref target="security" format="default"/>),
          synchronization objectives that are flooded SHOULD NOT contain unencrypted private
          information and SHOULD be validated by the recipient ASA.</t>
          </section>
          <section anchor="rapidsynch" numbered="true" toc="default">
            <name>Rapid Mode (Discovery/Synchronization Linkage)</name>
            <t>A Discovery message MAY include a Synchronization
             Objective option. In this case the Discovery message also acts
             as a Request Synchronization message to indicate to the Discovery Responder
             that it could directly reply to the Discovery Initiator with
             a Synchronization message <xref target="SynchMessage" format="default"/> with synchronization data for rapid processing,
             if the discovery target supports the corresponding synchronization
             objective. The design implications are similar to those discussed in <xref target="rapidneg" format="default"/>.</t>
            <t>It is possible that a Discovery Response will arrive from a responder that
             does not support rapid mode, before such a Synchronization message arrives.
             In this case, rapid mode will not occur.</t>
            <t>This rapid mode could reduce the interactions between
             nodes so that a higher efficiency could be achieved. However, a network in which some
             nodes support rapid mode and others do not will have complex timing-dependent behaviors.
             Therefore, the rapid synchronization function SHOULD be configured off by default
             and MAY be configured on or off by Intent.</t>
          </section>
        </section>
      </section>
      <section anchor="Constants" numbered="true" toc="default">
        <name>GRASP Constants</name>
        <ul spacing="normal">
          <li>
            <t>ALL_GRASP_NEIGHBORS</t>
            <t>A link-local
            scope multicast address used by a GRASP-enabled device to discover
            GRASP-enabled neighbor (i.e., on-link) devices. All devices that
            support GRASP are members of this multicast group.</t>
            <ul spacing="normal">
              <li>IPv6 multicast address: ff02::13</li>
              <li>IPv4 multicast address: 224.0.0.119</li>
            </ul>
          </li>
          <li>
            <t>GRASP_LISTEN_PORT (7017)</t>
            <t>A well-known UDP user port that
            every GRASP-enabled network device MUST listen to for link-local multicasts when UDP
            is used for M_DISCOVERY or M_FLOOD messages in the GRASP instance
            This user port MAY also be used to listen for TCP or UDP unicast messages
            in a simple implementation of GRASP (<xref target="trans" format="default"/>).</t>
          </li>
          <li>
            <t>GRASP_DEF_TIMEOUT (60000 milliseconds)</t>
            <t>The default timeout used to
            determine that an operation has failed to complete.</t>
          </li>
          <li>
            <t>GRASP_DEF_LOOPCT (6)</t>
            <t>The default loop count used to
            determine that a negotiation has failed to complete, and to avoid looping messages.</t>
          </li>
          <li>
            <t>GRASP_DEF_MAX_SIZE (2048)</t>
            <t>The default maximum message size in bytes.</t>
          </li>
        </ul>
      </section>
      <section anchor="SessionID" numbered="true" toc="default">
        <name>Session Identifier (Session ID)</name>
        <t>This is an up to 32-bit opaque value used to distinguish multiple sessions between
        the same two devices. A new Session ID MUST be generated by the initiator for every
        new Discovery, Flood Synchronization or Request message. All responses and follow-up messages in the same 
        discovery, synchronization or negotiation procedure MUST carry the same Session ID.</t>
        <t>The Session ID SHOULD have a very low collision rate locally. It
        MUST be generated by a pseudo-random number generator (PRNG) using a locally
        generated seed which is unlikely to be used by any other device in the same
        network. The PRNG SHOULD be cryptographically strong <xref target="RFC4086" format="default"/>.
        When allocating a new Session ID, GRASP MUST
        check that the value is not already in use and SHOULD check that it has not been
        used recently, by consulting a cache of current and recent sessions. In the unlikely
        event of a clash, GRASP MUST generate a new value.</t>
        <t>However, there is a finite probability that two nodes might generate the same
        Session ID value. For that reason, when a Session ID is communicated via GRASP, the
        receiving node MUST tag it with the initiator's IP address to allow disambiguation.
        In the highly unlikely event of two peers opening sessions with the same
        Session ID value, this tag will allow the two sessions to be distinguished.
        Multicast GRASP messages and their responses, which may be relayed between links,
        therefore include a field that carries the initiator's global IP address.</t>
        <t>There is a highly unlikely race condition in which two peers start simultaneous negotiation
        sessions with each other using the same Session ID value. Depending on various
        implementation choices, this might lead to the two sessions being confused.
        See <xref target="RequestMessage" format="default"/> for details of how to avoid this.</t>
      </section>
      <section anchor="GRASPMessages" numbered="true" toc="default">
        <name>GRASP Messages</name>
        <section numbered="true" toc="default">
          <name>Message Overview</name>
          <t>This section defines the GRASP message format and message types.
          Message types not listed here are reserved for future use. </t>
          <t>The messages currently defined are:
          </t>
          <ul spacing="normal">
            <li>Discovery and Discovery Response (M_DISCOVERY, M_RESPONSE).</li>
            <li>Request Negotiation, Negotiation, Confirm Waiting and Negotiation End (M_REQ_NEG, M_NEGOTIATE, M_WAIT, M_END).</li>
            <li>Request Synchronization, Synchronization, and Flood Synchronization (M_REQ_SYN, M_SYNCH, M_FLOOD.</li>
            <li>No Operation and Invalid (M_NOOP, M_INVALID).</li>
          </ul>
        </section>
        <section numbered="true" toc="default">
          <name>GRASP Message Format</name>
          <t>GRASP messages share an identical header format and a
          variable format area for options. GRASP message headers and options
          are transmitted in Concise Binary Object Representation (CBOR) 
          <xref target="RFC7049" format="default"/>. In this specification, they are described
          using CBOR data definition language (CDDL)
          <xref target="RFC8610" format="default"/>.
          Fragmentary CDDL is used to describe each item in this section. A complete and normative
          CDDL specification of GRASP is given in <xref target="cddl" format="default"/>, including constants such
          as message types.
          </t>
          <t>Every GRASP message, except the No Operation message, carries a Session ID (<xref target="SessionID" format="default"/>).
          Options are then presented serially in the options field.</t>
          <t>In fragmentary CDDL, every GRASP message follows the pattern:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
  grasp-message = (message .within message-structure) / noop-message

  message-structure = [MESSAGE_TYPE, session-id, ?initiator,
                       *grasp-option]

  MESSAGE_TYPE = 1..255
  session-id = 0..4294967295 ;up to 32 bits
  grasp-option = any
  ]]></artwork>
          <t>The MESSAGE_TYPE indicates the type of the message and thus defines 
          the expected options. Any options received that are not consistent with
          the MESSAGE_TYPE SHOULD be silently discarded. </t>
          <t>The No Operation (noop) message is  described in <xref target="noop" format="default"/>.</t>
          <t>The various MESSAGE_TYPE values are defined in <xref target="cddl" format="default"/>.</t>
          <t>All other message elements are described below and formally defined in <xref target="cddl" format="default"/>.</t>
          <t>If an unrecognized MESSAGE_TYPE is received in a unicast message,
          an Invalid message (<xref target="invalid" format="default"/>) MAY be returned. Otherwise the message
          MAY be logged and MUST be discarded. If an unrecognized MESSAGE_TYPE is received
          in a multicast message, it MAY be logged and MUST be silently discarded.</t>
        </section>
        <section numbered="true" toc="default">
          <name>Message Size</name>
          <t>GRASP nodes MUST be able to receive unicast messages of at least GRASP_DEF_MAX_SIZE bytes. GRASP nodes
        MUST NOT send unicast messages longer than GRASP_DEF_MAX_SIZE bytes unless a longer size is explicitly
        allowed for the objective concerned. For example, GRASP negotiation itself could be used 
        to agree on a longer message size.</t>
          <t>The message parser used by GRASP should be configured to know about the GRASP_DEF_MAX_SIZE, or
        any larger negotiated message size, so that it may defend against overly long messages.</t>
          <t>The maximum size of multicast messages (M_DISCOVERY and M_FLOOD) depends on the link
        layer technology or link adaptation layer in use.</t>
        </section>
        <section anchor="DiscoveryMessage" numbered="true" toc="default">
          <name>Discovery Message</name>
          <t>In fragmentary CDDL, a Discovery message follows the pattern:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
  discovery-message = [M_DISCOVERY, session-id, initiator, objective]
  ]]></artwork>
          <t>
          A discovery initiator sends a Discovery message
               to initiate a discovery process for a particular objective option.
          </t>
          <t>

               The discovery initiator sends all Discovery 
               messages via UDP to port GRASP_LISTEN_PORT at the link-local
               ALL_GRASP_NEIGHBORS multicast address on each link-layer interface in use by GRASP.
               It then listens for unicast TCP responses on a given port, and stores the discovery 
               results (including responding discovery objectives and
               corresponding unicast locators). 
          </t>
          <t>The listening port used for TCP MUST be the same port as used for sending the
               Discovery UDP multicast, on a given interface. In an implementation with a
               single GRASP instance in a node this MAY be GRASP_LISTEN_PORT. To support
               multiple instances in the same node, the GRASP discovery mechanism in each
               instance needs to find, for each interface, a dynamic port that it can bind to
               for both sending UDP link-local multicast and listening for TCP, before
               initiating any discovery.</t>
          <t>
               The 'initiator' field in the message is a globally unique IP address of the
               initiator, for the sole purpose of disambiguating the Session ID
               in other nodes. If for some reason the initiator does not
               have a globally unique IP address, it MUST use a link-local
               address for this purpose that is highly likely to be
               unique, for example using <xref target="RFC7217" format="default"/>. Determination
               of a node's globally unique IP address is implementation-dependent.
          </t>
          <t>
               A Discovery message MUST include exactly one of the following:
          </t>
          <ul spacing="normal">
            <li>a discovery objective option (<xref target="ObjForm" format="default"/>).
               Its loop count MUST be set to a suitable value to prevent discovery
               loops (default value is GRASP_DEF_LOOPCT). If the discovery initiator
               requires only on-link responses, the loop count MUST be set to 1.
               </li>
            <li>a negotiation objective option (<xref target="ObjForm" format="default"/>). This
               is used both for the purpose of discovery and to indicate 
               to the discovery target that it MAY directly reply to 
               the discovery initiatior with a Negotiation message for 
               rapid processing, if it could act as the corresponding negotiation counterpart.
               The sender of such a Discovery message MUST initialize
               a negotiation timer and loop count in the same way as a Request Negotiation message
               (<xref target="RequestMessage" format="default"/>).
               </li>
            <li>a synchronization objective option (<xref target="ObjForm" format="default"/>).
               This is used both for the purpose of discovery and to indicate to the discovery
               target that it MAY directly reply to the discovery initiator with a Synchronization message
               for rapid processing, if it could act as the corresponding synchronization counterpart.
               Its loop count MUST be set to a suitable value to prevent discovery
               loops (default value is GRASP_DEF_LOOPCT).</li>
          </ul>
          <t>As mentioned in <xref target="discovw" format="default"/>, a Discovery message MAY be sent unicast to a peer node,
                which SHOULD then proceed exactly as if the message had been multicast.
          </t>
        </section>
        <section anchor="ResponseMessage" numbered="true" toc="default">
          <name>Discovery Response Message</name>
          <t>In fragmentary CDDL, a Discovery Response message follows the pattern:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
  response-message = [M_RESPONSE, session-id, initiator, ttl,
                     (+locator-option // divert-option), ?objective)]
                    
  ttl = 0..4294967295 ; in milliseconds
  ]]></artwork>
          <t>
          A node which receives a Discovery message SHOULD send a 
          Discovery Response message if and only if it can respond to the discovery.
          </t>
          <ul empty="true" spacing="normal">
            <li>It MUST contain the same Session ID and initiator as the Discovery message.
          </li>
            <li>It MUST contain a time-to-live (ttl) for the validity of the response, given 
          as a positive integer value in milliseconds. Zero implies a value significantly
          greater than GRASP_DEF_TIMEOUT milliseconds (<xref target="Constants" format="default"/>). A suggested
          value is ten times that amount.
          </li>
            <li>It MAY include a copy of the discovery objective from
          the Discovery message.</li>
          </ul>
          <t>
          It is sent to the sender of the Discovery message via TCP 
          at the port used to send the Discovery message (as explained in <xref target="DiscoveryMessage" format="default"/>).
          In the case of a relayed Discovery message, the Discovery Response
          is thus sent to the relay, not the original initiator.
          </t>
          <t>
          In all cases, the transport session SHOULD be closed after sending the Discovery Response.
          A transport session failure is treated as no response.
          </t>
          <t>

          If the responding node supports the discovery objective 
          of the discovery, it MUST include at least one kind of 
          locator option (<xref target="LocatorOption" format="default"/>) to indicate its own 
          location. A sequence of multiple kinds of locator 
          options (e.g. IP address option and FQDN option) is also 
          valid.
          </t>
          <t>

          If the responding node itself does not support the discovery 
          objective, but it knows the locator of the discovery 
          objective, then it SHOULD respond to the discovery message with a 
          divert option (<xref target="DivertOption" format="default"/>) embedding a locator 
          option or a combination of multiple kinds of locator
          options which indicate the locator(s) of the discovery objective.
          </t>
          <t>More details on the processing of Discovery Responses are given in
          <xref target="discmech" format="default"/>.</t>
        </section>
        <section anchor="RequestMessage" numbered="true" toc="default">
          <name>Request Messages</name>
          <t>In fragmentary CDDL, Request Negotiation and Request Synchronization messages follow the patterns:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[

request-negotiation-message = [M_REQ_NEG, session-id, objective]

request-synchronization-message = [M_REQ_SYN, session-id, objective]

  ]]></artwork>
          <t>
          A negotiation or synchronization requesting node
          sends the appropriate Request message to the unicast address of the negotiation or
          synchronization counterpart, using the appropriate protocol and port numbers
          (selected from the discovery result). If the discovery result is an FQDN,
          it will be resolved first.</t>
          <t>A Request message MUST include the relevant objective option. In the case of
          Request Negotiation, the objective option MUST include the requested value. </t>
          <t>When an initiator sends a Request Negotiation message, it MUST initialize a negotiation timer
          for the new negotiation thread. The default is GRASP_DEF_TIMEOUT milliseconds. Unless this 
          timeout is modified by a Confirm Waiting message (<xref target="ConfirmWaitingMessage" format="default"/>),
          the initiator will consider that the negotiation has failed when the timer expires. </t>
          <t>Similarly, when an initiator sends a Request Synchronization, it SHOULD initialize
          a synchronization timer. The default is GRASP_DEF_TIMEOUT milliseconds.
          The initiator will consider that synchronization has failed 
          if there is no response before the timer expires.</t>
          <t>When an initiator sends a Request message, it MUST initialize the loop count
          of the objective option with a value defined in the specification of the option
          or, if no such value is specified, with GRASP_DEF_LOOPCT. </t>
          <t>If a node receives a Request message for an objective for which no ASA is currently
          listening, it MUST immediately close the relevant socket to indicate this to the initiator.
          This is to avoid unnecessary timeouts if, for example, an ASA exits prematurely
          but the GRASP core is listening on its behalf.</t>
          <t>To avoid the highly unlikely race condition in which two nodes simultaneously request
          sessions with each other using the same Session ID (<xref target="SessionID" format="default"/>), when a node receives a Request message,
          it MUST verify that the received Session ID is not already locally active. In case of a clash,
          it MUST discard the Request message, in which case the initiator will detect a timeout.</t>
        </section>
        <section anchor="NegotiationMessage" numbered="true" toc="default">
          <name>Negotiation Message</name>
          <t>In fragmentary CDDL, a Negotiation message follows the pattern:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
  negotiate-message = [M_NEGOTIATE, session-id, objective]
  ]]></artwork>
          <t>A negotiation counterpart sends a Negotiation
          message in response to a Request Negotiation message, a 
          Negotiation message, or a Discovery message
          in Rapid Mode. A negotiation process MAY
          include multiple steps.</t>
          <t>The Negotiation message MUST include the relevant Negotiation Objective option,
          with its value updated according to progress in the negotiation. The sender
          MUST decrement the loop count by 1. If the loop count becomes zero the message
          MUST NOT be sent. In this case the negotiation session has failed and will time out.</t>
        </section>
        <section anchor="NegotiationEndingMessage" numbered="true" toc="default">
          <name>Negotiation End Message</name>
          <t>In fragmentary CDDL, a Negotiation End message follows the pattern:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
  end-message = [M_END, session-id, accept-option / decline-option]
  ]]></artwork>
          <t>
          A negotiation counterpart sends an Negotiation End
          message to close the negotiation. It MUST contain 
          either an accept or a decline option, 
          defined in <xref target="AcceptOption" format="default"/> and <xref target="DeclineOption" format="default"/>.
          It could be sent either by the 
          requesting node or the responding node.</t>
        </section>
        <section anchor="ConfirmWaitingMessage" numbered="true" toc="default">
          <name>Confirm Waiting     Message</name>
          <t>In fragmentary CDDL, a Confirm Waiting     message follows the pattern:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
  wait-message = [M_WAIT, session-id, waiting-time]
  waiting-time = 0..4294967295 ; in milliseconds
  ]]></artwork>
          <t>
          A responding node sends a Confirm Waiting     message to
          ask the requesting node to wait for a further
          negotiation response. It might be that the local
          process needs more time or that the negotiation 
          depends on another triggered negotiation. This
          message MUST NOT include any other options.
          When received, the waiting time value overwrites 
          and restarts the current negotiation timer
          (<xref target="RequestMessage" format="default"/>).</t>
          <t>The responding node SHOULD send a Negotiation, Negotiation End or another
          Confirm Waiting message before the negotiation timer expires. If
          not, when the initiator's timer expires, the initiator MUST treat
          the negotiation procedure as failed.</t>
        </section>
        <section anchor="SynchMessage" numbered="true" toc="default">
          <name>Synchronization Message</name>
          <t>In fragmentary CDDL, a Synchronization message follows the pattern:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
  synch-message = [M_SYNCH, session-id, objective]
  ]]></artwork>
          <t>A node which receives a Request Synchronization, or
             a Discovery message in Rapid Mode, sends back a unicast Synchronization
             message with the synchronization data, in the form of a GRASP Option for the specific
             synchronization objective present in the Request Synchronization.</t>
        </section>
        <section anchor="FloodMessage" numbered="true" toc="default">
          <name>Flood Synchronization Message</name>
          <t>In fragmentary CDDL, a Flood Synchronization message follows the pattern:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
  flood-message = [M_FLOOD, session-id, initiator, ttl,
                  +[objective, (locator-option / [])]]
                  
  ttl = 0..4294967295 ; in milliseconds
  ]]></artwork>
          <t>
          A node MAY initiate flooding by sending an unsolicited Flood Synchronization Message
          with synchronization data. This MAY be sent to port GRASP_LISTEN_PORT at the
          link-local ALL_GRASP_NEIGHBORS multicast address, in accordance
          with the rules in <xref target="synchproc" format="default"/>.
          </t>
          <ul empty="true" spacing="normal">
            <li>
          The initiator address is provided, as described for Discovery messages (<xref target="DiscoveryMessage" format="default"/>),
          only to disambiguate the Session ID.
          </li>
            <li>
          The message MUST contain a time-to-live (ttl) for the validity of the contents, given 
          as a positive integer value in milliseconds. There is no default;
          zero indicates an indefinite lifetime.
          </li>
            <li>
          The synchronization data are in the form of GRASP Option(s) for specific
          synchronization objective(s). The loop count(s) MUST be set to a suitable
          value to prevent flood loops (default value is GRASP_DEF_LOOPCT).</li>
            <li>
          Each objective option MAY be followed by a locator option associated with
          the flooded objective. In its absence, an empty option MUST be included
          to indicate a null locator.
          </li>
          </ul>
          <t>
          A node that receives a Flood Synchronization message MUST cache the received objectives for
          use by local ASAs. Each cached objective MUST be tagged with the locator option sent with it, or with a null
          tag if an empty locator option was sent. If a subsequent Flood Synchronization message carrying an objective
          with same name and the same tag, the corresponding cached copy of the objective MUST be overwritten.
          If a subsequent Flood Synchronization message carrying an objective with same name arrives with a different
          tag, a new cached entry MUST be created.</t>
          <t>Note: the purpose of this mechanism is to allow the recipient of flooded values to distinguish between
          different senders of the same objective, and if necessary communicate with them using the locator, protocol
          and port included in the locator option. Many objectives will not need this mechanism, so they will be flooded
          with a null locator.</t>
          <t>Cached entries MUST be ignored or deleted after their lifetime expires.</t>
        </section>
        <section anchor="invalid" numbered="true" toc="default">
          <name>Invalid Message</name>
          <t>In fragmentary CDDL, an Invalid message follows the pattern:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
  invalid-message = [M_INVALID, session-id, ?any]
  ]]></artwork>
          <t>
          This message MAY be sent by an implementation in response to an incoming unicast message that it considers
          invalid. The session-id MUST be copied from the incoming message. The content SHOULD
          be diagnostic information such as a partial copy of the invalid message up to the
          maximum message size. An M_INVALID message
          MAY be silently ignored by a recipient. However, it could be used in support of
          extensibility, since it indicates that the remote node does not support a new or
          obsolete message or option.</t>
          <t>An M_INVALID message MUST NOT be sent in response to an M_INVALID message.</t>
        </section>
        <section anchor="noop" numbered="true" toc="default">
          <name>No Operation Message</name>
          <t>In fragmentary CDDL, a No Operation message follows the pattern:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
  noop-message = [M_NOOP]
  ]]></artwork>
          <t>
          This message MAY be sent by an implementation that for practical reasons needs to
          initialize a socket. It MUST be silently ignored by a recipient.</t>
        </section>
      </section>
      <section anchor="GRASPOptions" numbered="true" toc="default">
        <name>GRASP Options</name>
        <t>This section defines the GRASP options for the negotiation
        and synchronization protocol signaling. Additional
        options may be defined in the future.</t>
        <section numbered="true" toc="default">
          <name>Format of GRASP Options</name>
          <t>GRASP options are CBOR objects that MUST start with an unsigned integer identifying 
           the specific option type carried in this option. These option types are formally
           defined in <xref target="cddl" format="default"/>. Apart from that the only format requirement
           is that each option MUST be a well-formed CBOR object. In general a CBOR array format
           is RECOMMENDED to limit overhead.</t>
          <t>GRASP options may be defined to include encapsulated GRASP options.</t>
        </section>
        <section anchor="DivertOption" numbered="true" toc="default">
          <name>Divert Option</name>
          <t>The Divert option is used to redirect a GRASP request to another
          node, which may be more appropriate for the intended negotiation or synchronization. It
          may redirect to an entity that is known as a specific negotiation or synchronization
          counterpart (on-link or off-link) or a default gateway. The divert
          option MUST only be encapsulated in Discovery Response messages.
          If found elsewhere, it SHOULD be silently ignored.</t>
          <t>A discovery initiator MAY ignore a Divert option if it only requires direct
          discovery responses. </t>
          <t>In fragmentary CDDL, the Divert option follows the pattern:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
  divert-option = [O_DIVERT, +locator-option]
  ]]></artwork>
          <t>The embedded Locator Option(s) (<xref target="LocatorOption" format="default"/>)
        point to diverted destination target(s) in response to a Discovery message. </t>
        </section>
        <section anchor="AcceptOption" numbered="true" toc="default">
          <name>Accept Option</name>
          <t>The accept option is used to indicate to the negotiation counterpart
          that the proposed negotiation content is accepted.</t>
          <t>The accept option MUST only be encapsulated in Negotiation End 
          messages. If found elsewhere, it SHOULD be silently ignored.</t>
          <t>In fragmentary CDDL, the Accept option follows the pattern:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
  accept-option = [O_ACCEPT]
  ]]></artwork>
        </section>
        <section anchor="DeclineOption" numbered="true" toc="default">
          <name>Decline Option</name>
          <t>The decline option is used to indicate to the negotiation
          counterpart the proposed negotiation content is declined and end the
          negotiation process.</t>
          <t>The decline option MUST only be encapsulated in
          Negotiation End messages. If found elsewhere, it SHOULD be
          silently ignored.</t>
          <t>In fragmentary CDDL, the Decline option follows the pattern:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
  decline-option = [O_DECLINE, ?reason]
  reason = text  ;optional UTF-8 error message
  ]]></artwork>
          <t>Note: there might be scenarios where an ASA wants
          to decline the proposed value and restart the negotiation process.
          In this case it is an implementation choice whether to send a Decline
          option or to continue with a Negotiate message, with an objective
          option that contains a null value, or one that contains a new
          value that might achieve convergence.</t>
        </section>
        <section anchor="LocatorOption" numbered="true" toc="default">
          <name>Locator Options</name>
          <t>These locator options are used to present reachability information for an ASA,
          a device or an interface. They are Locator IPv6 Address
          Option, Locator IPv4 Address Option, Locator FQDN (Fully
          Qualified Domain Name) Option and URI (Uniform Resource Identifier) Option.</t>
          <t>Since ASAs will normally run as independent user programs, locator options need
          to indicate the network layer locator plus the transport protocol and port number for
          reaching the target. For this reason, the Locator Options for IP addresses
          and FQDNs include this information explicitly. In the case of the URI Option,
          this information can be encoded in the URI itself.</t>
          <t>Note: It is assumed that all locators used in locator options are in scope throughout
          the GRASP domain. As stated in <xref target="hilev" format="default"/>,
          GRASP is not intended to work across disjoint addressing
          or naming realms. </t>
          <section numbered="true" toc="default">
            <name>Locator IPv6 address option</name>
            <t>In fragmentary CDDL, the IPv6 address option follows the pattern:</t>
            <artwork name="" type="" align="left" alt=""><![CDATA[
  ipv6-locator-option = [O_IPv6_LOCATOR, ipv6-address,
                         transport-proto, port-number]
  ipv6-address = bytes .size 16

  transport-proto = IPPROTO_TCP / IPPROTO_UDP
  IPPROTO_TCP = 6
  IPPROTO_UDP = 17
  port-number = 0..65535
  ]]></artwork>
            <t>The content of this option is a binary IPv6 address followed by the protocol number and port number to be used.</t>
            <t>Note 1: The IPv6 address MUST normally have global scope. However, during initialization,
          a link-local address MAY be used for specific objectives only (<xref target="secinst" format="default"/>). In this case
          the corresponding Discovery Response message MUST be sent via the interface to which the link-local
          address applies.</t>
            <t>Note 2: A link-local IPv6 address MUST NOT be used when this option is included in a Divert option.</t>
            <t>Note 3: The IPPROTO values are taken from the existing IANA Protocol Numbers registry in order
          to specify TCP or UDP. If GRASP
          requires future values that are not in that registry, a new registry for values outside the range 0..255
          will be needed.</t>
          </section>
          <section numbered="true" toc="default">
            <name>Locator IPv4 address option</name>
            <t>In fragmentary CDDL, the IPv4 address option follows the pattern:</t>
            <artwork name="" type="" align="left" alt=""><![CDATA[
  ipv4-locator-option = [O_IPv4_LOCATOR, ipv4-address,
                         transport-proto, port-number]
  ipv4-address = bytes .size 4
  ]]></artwork>
            <t>The content of this option is a binary IPv4 address followed by the protocol number and port number to be used.</t>
            <t>Note: If an operator has internal network address translation for IPv4,
          this option MUST NOT be used within the Divert option.</t>
          </section>
          <section numbered="true" toc="default">
            <name>Locator FQDN option</name>
            <t>In fragmentary CDDL, the FQDN option follows the pattern:</t>
            <artwork name="" type="" align="left" alt=""><![CDATA[
  fqdn-locator-option = [O_FQDN_LOCATOR, text,
                         transport-proto, port-number]
  ]]></artwork>
            <t>The content of this option is the Fully Qualified Domain Name of the target followed by the protocol number and port number to be used.
            </t>
            <t>Note 1: Any FQDN which might not be valid throughout the network in question,
          such as a Multicast DNS name <xref target="RFC6762" format="default"/>, MUST NOT be used when
          this option is used within the Divert option.</t>
            <t>Note 2: Normal GRASP operations are not expected to use this option. It is intended for
          special purposes such as discovering external services.</t>
          </section>
          <section numbered="true" toc="default">
            <name>Locator URI option</name>
            <t>In fragmentary CDDL, the URI option follows the pattern:</t>
            <artwork name="" type="" align="left" alt=""><![CDATA[
  uri-locator = [O_URI_LOCATOR, text,
                 transport-proto / null, port-number / null]
  ]]></artwork>
            <t>The content of this option is the Uniform Resource Identifier of the target
          followed by the protocol number and port number to be used (or by null values if not required)
          <xref target="RFC3986" format="default"/>.
            </t>
            <t>Note 1: Any URI which might not be valid throughout the network in question,
          such as one based on a Multicast DNS name <xref target="RFC6762" format="default"/>, MUST NOT be used when
          this option is used within the Divert option.</t>
            <t>Note 2: Normal GRASP operations are not expected to use this option. It is intended for
          special purposes such as discovering external services. Therefore its use is not further
          described in this specification.</t>
          </section>
        </section>
        <!---->
      </section>
      <section anchor="ObjOption" numbered="true" toc="default">
        <name>Objective Options</name>
        <section anchor="ObjForm" numbered="true" toc="default">
          <name>Format of Objective Options</name>
          <t>An objective option is used to identify objectives for
        the purposes of discovery, negotiation or synchronization.
        All objectives MUST be in the following format,
        described in fragmentary CDDL:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
  objective = [objective-name, objective-flags, loop-count, ?objective-value]
           
  objective-name = text
  objective-value = any 
  loop-count = 0..255
  ]]></artwork>
          <t>All objectives are identified by a unique name which is a UTF-8 string <xref target="RFC3629" format="default"/>, to be
          compared byte by byte. </t>
          <t>The names of generic objectives MUST NOT include a colon (":")
          and MUST be registered with IANA (<xref target="iana" format="default"/>).</t>
          <t>The names of privately defined objectives MUST include at least one colon (":"). 
          The string preceding the last colon in the name MUST be globally unique and in some
          way identify the entity or person defining the objective. The following three methods
          MAY be used to create such a globally unique string:
          </t>
          <ol spacing="normal" type="1">
            <li>The unique string is a decimal number representing a registered 32 bit Private Enterprise
          Number (PEN) <xref target="RFC5612" format="default"/> that uniquely identifies the enterprise
          defining the objective.</li>
            <li>The unique string is a fully qualified domain name that uniquely identifies the entity or person
          defining the objective.</li>
            <li>The unique string is an email address that uniquely identifies the entity or person
          defining the objective.</li>
          </ol>
          <t> 
          
          The GRASP protocol treats the objective name as an opaque string. For example, "EX1", "32473:EX1", 
          "example.com:EX1", "example.org:EX1 and "user@example.org:EX1" would be five different objectives.</t>
          <t>The 'objective-flags' field is described below.</t>
          <t>The 'loop-count' field is used for terminating negotiation as described in
          <xref target="NegotiationMessage" format="default"/>. It is also used for terminating discovery as
          described in <xref target="discmech" format="default"/>, and for terminating flooding as described in
          <xref target="flooding" format="default"/>. It is placed in the objective rather than in the GRASP
          message format because, as far as the ASA is concerned, it is a property of the
          objective itself.
          </t>
          <t>
          The 'objective-value' field is to express the actual value of a negotiation
          or synchronization objective. Its format is defined in the
          specification of the objective and may be a simple value
          or a data structure of any kind, as long as it can be represented in CBOR.
          It is optional because it is optional in a Discovery or Discovery Response message.</t>
        </section>
        <section numbered="true" toc="default">
          <name>Objective flags</name>
          <t>An objective may be relevant for discovery only, for discovery and negotiation, or
         for discovery and synchronization. This is expressed in the objective by logical flag bits:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
  objective-flags = uint .bits objective-flag
  objective-flag = &(
  F_DISC: 0    ; valid for discovery
  F_NEG: 1     ; valid for negotiation
  F_SYNCH: 2   ; valid for synchronization
  F_NEG_DRY: 3 ; negotiation is dry-run
  )
  ]]></artwork>
          <t>These bits are independent and may be combined appropriately, e.g. (F_DISC and F_SYNCH) or 
         (F_DISC and F_NEG) or (F_DISC and F_NEG and F_NEG_DRY).</t>
          <t>Note that for a given negotiation session, an objective must be either used for negotiation, or for
         dry-run negotiation. Mixing the two modes in a single negotiation is not possible.</t>
        </section>
        <section anchor="ConsOption" numbered="true" toc="default">
          <name>General Considerations for Objective Options</name>
          <t>As mentioned above, Objective Options MUST be assigned a unique name.
        As long as privately defined Objective Options obey the rules above, this document
        does not restrict their choice of name, but the entity or person concerned SHOULD publish the names in use. </t>
          <t>Names are expressed as UTF-8 strings for convenience in designing Objective Options for
        localized use. For generic usage, names expressed in the ASCII subset of UTF-8 are RECOMMENDED.
        Designers planning to use non-ASCII names are strongly advised to consult <xref target="RFC7564" format="default"/>
        or its successor
        to understand the complexities involved. Since the GRASP protocol compares names byte by byte,
        all issues of Unicode profiling and canonicalization MUST be specified in the design of the
        Objective Option.</t>
          <t>All Objective Options MUST respect the CBOR patterns defined above as "objective"
        and MUST replace the "any" field with a valid CBOR data definition
        for the relevant use case and application. </t>
          <t>An Objective Option that contains no additional
        fields beyond its "loop-count" can only be a discovery objective and MUST only be used
        in Discovery and Discovery Response messages.</t>
          <t>The Negotiation Objective Options contain negotiation objectives,
        which vary according to different functions/services. They MUST
        be carried by Discovery, Request Negotiation or Negotiation messages only. The negotiation
        initiator MUST set the initial "loop-count" to a value specified in the
        specification of the objective or, if no such value is specified, to 
        GRASP_DEF_LOOPCT.</t>
          <t>For most scenarios, there should be initial values in the
        negotiation requests. Consequently, the Negotiation Objective options MUST
        always be completely presented in a Request Negotiation message, or in a Discovery
        message in rapid mode. If there is no
        initial value, the value field SHOULD be set to the 'null' value defined
        by CBOR.</t>
          <t>Synchronization Objective Options are similar, but MUST be carried
        by Discovery, Discovery Response, Request Synchronization, or Flood Synchronization
        messages only. They include
        value fields only in Synchronization or Flood Synchronization messages. </t>
          <t>The design of an objective interacts in various ways with the design of the ASAs
        that will use it. ASA design considerations are discussed in
        <xref target="I-D.carpenter-anima-asa-guidelines" format="default"/>.</t>
        </section>
        <section numbered="true" toc="default">
          <name>Organizing of Objective Options</name>
          <t>Generic objective options MUST be specified in documents
          available to the public and SHOULD be designed to use either
          the negotiation or the synchronization mechanism described above.
          </t>
          <t>As noted earlier, one negotiation objective is handled by each
          GRASP negotiation thread. Therefore, a negotiation objective, which is
          based on a specific function or action, SHOULD be organized as a single
          GRASP option. It is NOT RECOMMENDED to organize multiple negotiation
          objectives into a single option, nor to split a single function
          or action into multiple negotiation objectives. </t>
          <t>It is important to understand that GRASP negotiation does not 
          support transactional integrity. If transactional integrity is needed for
          a specific objective, this must be ensured by the ASA. For example, an ASA
          might need to ensure that it only participates in one negotiation thread
          at the same time. Such an ASA would need to stop listening for incoming
          negotiation requests before generating an outgoing negotiation request.</t>
          <t>A synchronization objective SHOULD be organized as a single GRASP option.</t>
          <t>Some objectives will support more than one operational mode.
          An example is a negotiation objective with both a "dry run" mode
          (where the negotiation is to find out whether the other end can in fact
          make the requested change without problems) and a "live" mode, as explained
          in <xref target="negproc" format="default"/>. The semantics of such
          modes will be defined in the specification of the objectives. These
          objectives SHOULD include flags indicating the
          applicable mode(s).</t>
          <t>An issue requiring particular attention is that GRASP itself is
          not a transactionally safe protocol. Any state associated with a dry run operation,
          such as temporarily reserving a resource for subsequent use in a live
          run, is entirely a matter for the designer of the ASA concerned.</t>
          <t>As indicated in <xref target="terms" format="default"/>, an objective's value may
          include multiple parameters. Parameters
          might be categorized into two classes: the obligatory ones presented as
          fixed fields; and the optional ones presented in
          some other form of data structure embedded in CBOR. The format might be
          inherited from an existing management or configuration protocol, with
          the objective option acting as a carrier for that format.
          The data structure might be defined in a formal language, but that is a
          matter for the specifications of individual objectives.
          There are many candidates, according to the context, such as ABNF, RBNF,
          XML Schema, YANG, etc. The GRASP protocol itself is agnostic on
          these questions. The only restriction is that the format can be mapped
          into CBOR.</t>
          <t>It is NOT RECOMMENDED to mix parameters that have significantly
          different response time characteristics in a single objective. Separate
          objectives are more suitable for such a scenario.</t>
          <t>All objectives MUST support GRASP discovery. However, as mentioned
          in <xref target="highlevel" format="default"/>, it is acceptable for an ASA to use an alternative method
          of discovery. </t>
          <t>Normally, a GRASP objective will refer to specific technical parameters
          as explained in <xref target="terms" format="default"/>. However, it is acceptable to define
          an abstract objective for the purpose of managing or coordinating ASAs. 
          It is also acceptable to define a special-purpose objective for purposes
          such as trust bootstrapping or formation of the ACP.</t>
          <t>
            To guarantee convergence, a limited number of rounds or a timeout is needed
            for each negotiation objective. 
            Therefore, the definition of each negotiation objective SHOULD clearly specify
            this, for example a default loop count and timeout,
            so that the negotiation can always be terminated properly. If not,
            the GRASP defaults will apply.
          </t>
          <t>
            There must be a well-defined procedure for concluding that a negotiation cannot
            succeed, and if so deciding what happens next (e.g., deadlock
            resolution, tie-breaking, or revert to best-effort
            service). This MUST be specified for individual negotiation objectives.
          </t>
        </section>
        <section numbered="true" toc="default">
          <name>Experimental and Example Objective Options</name>
          <t>The names "EX0" through "EX9" have been reserved for experimental options.
          Multiple names have been assigned because a single experiment
          may use multiple options simultaneously. These experimental options
          are highly likely to have different meanings when used for different
          experiments. Therefore, they SHOULD NOT be used without an explicit
          human decision and MUST NOT be used in unmanaged networks such as
          home networks.</t>
          <t>These names are also RECOMMENDED for use in documentation 
          examples.</t>
        </section>
      </section>
    </section>
    
    <section anchor="security" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>A successful attack on negotiation-enabled nodes
      would be extremely harmful, as such nodes might end up with a completely
      undesirable configuration that would also adversely affect their peers.
      GRASP nodes and messages therefore require full protection. 
      As explained in <xref target="reqsec" format="default"/>, GRASP MUST run within a secure
      environment such as the Autonomic Control Plane
      <xref target="I-D.ietf-anima-autonomic-control-plane" format="default"/>,
      except for the constrained instances described in <xref target="secinst" format="default"/>.</t>
      <t>- Authentication</t>
      <dl newline="false" spacing="normal">
        <dt/>
        <dd>A cryptographically authenticated identity for each device is
          needed in an autonomic network. It is not safe to assume that a
          large network is physically secured against interference or that all
          personnel are trustworthy. Each autonomic node MUST be capable
          of proving its identity and authenticating its messages. GRASP
          relies on a separate external certificate-based security mechanism to support
          authentication, data integrity protection, and anti-replay protection.</dd>
        <dt/>
        <dd>Since GRASP must be deployed in an existing secure environment,
          the protocol itself specifies nothing concerning the trust anchor and 
          certification authority. For example, in the Autonomic Control Plane
          <xref target="I-D.ietf-anima-autonomic-control-plane" format="default"/>, all nodes can
          trust each other and the ASAs installed in them.</dd>
        <dt/>
        <dd>If GRASP is used temporarily without an external security mechanism,
          for example during system bootstrap (<xref target="reqsec" format="default"/>),
          the Session ID (<xref target="SessionID" format="default"/>) will act as a nonce to
          provide limited protection against third parties injecting responses.
          A full analysis of the secure bootstrap process is in
          <xref target="I-D.ietf-anima-bootstrapping-keyinfra" format="default"/>. </dd>
      </dl>
      <t>- Authorization and Roles</t>
      <dl newline="false" spacing="normal">
        <dt/>
        <dd>The GRASP protocol is agnostic about the roles and capabilities of individual
         ASAs and about which objectives a particular ASA is authorized to support. An implementation
         might support precautions such as allowing only one ASA in a given node to modify
         a given objective, but this may not be appropriate in all cases. For example,
         it might be operationally useful to allow an old and a new version of the same
         ASA to run simultaneously during an overlap period. These questions are out
         of scope for the present specification.</dd>
      </dl>
      <t>- Privacy and confidentiality</t>
      <dl newline="false" spacing="normal">
        <dt/>
        <dd>GRASP is intended for network management purposes involving
          network elements, not end hosts. Therefore, no personal information
          is expected to be involved in the signaling protocol, so there should be no direct
          impact on personal privacy. Nevertheless, applications that do
          convey personal information cannot be excluded. Also, traffic flow paths, VPNs,
          etc. could be negotiated, which could be of interest for traffic
          analysis. Operators generally want to conceal details of their
          network topology and traffic density from outsiders. Therefore,
          since insider attacks cannot be excluded in a large 
          network, the security mechanism for the protocol MUST
          provide message confidentiality. This is why <xref target="reqsec" format="default"/>
          requires either an ACP or an alternative security mechanism.</dd>
      </dl>
      <t>- Link-local multicast security</t>
      <dl newline="false" spacing="normal">
        <dt/>
        <dd>GRASP has no reasonable alternative to using link-local multicast
          for Discovery or Flood Synchronization messages and these messages are sent in clear and
          with no authentication. They are only sent on interfaces within the autonomic network
          (see <xref target="terms" format="default"/> and <xref target="reqsec" format="default"/>).
          They are however available to on-link eavesdroppers, and
          could be forged by on-link attackers. In the case of Discovery, the Discovery Responses
          are unicast and will therefore be protected (<xref target="reqsec" format="default"/>), and an untrusted
          forger will not be able to receive responses. In the case of Flood Synchronization, an on-link
          eavesdropper will be able to receive the flooded objectives but there is no response
          message to consider. Some precautions for Flood Synchronization messages
          are suggested in <xref target="flooding" format="default"/>.</dd>
      </dl>
      <t>- DoS Attack Protection</t>
      <dl newline="false" spacing="normal">
        <dt/>
        <dd>GRASP discovery partly relies on insecure link-local multicast. Since
          routers participating in GRASP sometimes relay discovery messages from one link
          to another, this could be a vector for denial of service attacks. Some
          mitigations are specified in <xref target="discmech" format="default"/>. However, malicious
          code installed inside the Autonomic Control Plane could always launch
          DoS attacks consisting of spurious discovery messages, or of spurious
          discovery responses. It is important that firewalls prevent any GRASP messages
          from entering the domain from an unknown source. </dd>
      </dl>
      <t>- Security during bootstrap and discovery</t>
      <dl newline="false" spacing="normal">
        <dt/>
        <dd>A node cannot trust GRASP traffic from other nodes until the security
          environment (such as the ACP) has identified the trust anchor and can authenticate traffic
          by validating certificates for other nodes. Also, until it has succesfully enrolled
          <xref target="I-D.ietf-anima-bootstrapping-keyinfra" format="default"/> a node cannot
          assume that other nodes are able to authenticate its own traffic.
          Therefore, GRASP discovery during the bootstrap phase for a new device
          will inevitably be insecure. Secure synchronization and negotiation
          will be impossible until enrollment is complete. Further details
          are given in <xref target="secinst" format="default"/>.</dd>
      </dl>
      <t>- Security of discovered locators</t>
      <dl newline="false" spacing="normal">
        <dt/>
        <dd>When GRASP discovery returns an IP address, it MUST be that of a node
          within the secure environment (<xref target="reqsec" format="default"/>). If it returns
          an FQDN or a URI, the ASA that receives it MUST NOT assume that the
          target of the locator is within the secure environment.</dd>
      </dl>
    </section>
    <section anchor="cddl" numbered="true" toc="default">
      <name>CDDL Specification of GRASP</name>
      <sourcecode name="" type="" markers="true"><![CDATA[
grasp-message = (message .within message-structure) / noop-message

message-structure = [MESSAGE_TYPE, session-id, ?initiator,
                     *grasp-option]

MESSAGE_TYPE = 0..255
session-id = 0..4294967295 ;up to 32 bits
grasp-option = any

message /= discovery-message
discovery-message = [M_DISCOVERY, session-id, initiator, objective]

message /= response-message ;response to Discovery
response-message = [M_RESPONSE, session-id, initiator, ttl,
                   (+locator-option // divert-option), ?objective]

message /= synch-message ;response to Synchronization request
synch-message = [M_SYNCH, session-id, objective] 

message /= flood-message
flood-message = [M_FLOOD, session-id, initiator, ttl,
                +[objective, (locator-option / [])]]

message /= request-negotiation-message
request-negotiation-message = [M_REQ_NEG, session-id, objective]

message /= request-synchronization-message
request-synchronization-message = [M_REQ_SYN, session-id, objective]

message /= negotiation-message
negotiation-message = [M_NEGOTIATE, session-id, objective]

message /= end-message
end-message = [M_END, session-id, accept-option / decline-option ]

message /= wait-message
wait-message = [M_WAIT, session-id, waiting-time]

message /= invalid-message
invalid-message = [M_INVALID, session-id, ?any]

noop-message = [M_NOOP]

divert-option = [O_DIVERT, +locator-option]

accept-option = [O_ACCEPT]

decline-option = [O_DECLINE, ?reason]
reason = text  ;optional UTF-8 error message

waiting-time = 0..4294967295 ; in milliseconds
ttl = 0..4294967295 ; in milliseconds

locator-option /= [O_IPv4_LOCATOR, ipv4-address,
                   transport-proto, port-number]
ipv4-address = bytes .size 4

locator-option /= [O_IPv6_LOCATOR, ipv6-address,
                   transport-proto, port-number]
ipv6-address = bytes .size 16

locator-option /= [O_FQDN_LOCATOR, text, transport-proto, port-number]

locator-option /= [O_URI_LOCATOR, text,
                   transport-proto / null, port-number / null]

transport-proto = IPPROTO_TCP / IPPROTO_UDP
IPPROTO_TCP = 6
IPPROTO_UDP = 17
port-number = 0..65535

initiator = ipv4-address / ipv6-address

objective-flags = uint .bits objective-flag

objective-flag = &(
  F_DISC: 0    ; valid for discovery
  F_NEG: 1     ; valid for negotiation
  F_SYNCH: 2   ; valid for synchronization
  F_NEG_DRY: 3 ; negotiation is dry-run
)

objective = [objective-name, objective-flags, loop-count, ?objective-value]

objective-name = text ;see section "Format of Objective Options"

objective-value = any 

loop-count = 0..255

; Constants for message types and option types

M_NOOP = 0
M_DISCOVERY = 1
M_RESPONSE = 2
M_REQ_NEG = 3
M_REQ_SYN = 4
M_NEGOTIATE = 5
M_END = 6
M_WAIT = 7
M_SYNCH = 8
M_FLOOD = 9
M_INVALID = 99

O_DIVERT = 100
O_ACCEPT = 101
O_DECLINE = 102
O_IPv6_LOCATOR = 103
O_IPv4_LOCATOR = 104
O_FQDN_LOCATOR = 105
O_URI_LOCATOR = 106
]]></sourcecode>
    </section>
    <section anchor="iana" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>This document defines the GeneRic Autonomic Signaling Protocol (GRASP).</t>
      <t><xref target="Constants" format="default"/> explains the following link-local multicast
      addresses, which IANA has assigned for use by GRASP:</t>
      <dl newline="false" spacing="normal">
        <dt>ALL_GRASP_NEIGHBORS multicast address</dt>
        <dd>(IPv6): ff02::13
          Assigned in the IPv6 Link-Local Scope Multicast Addresses registry.</dd>
        <dt>ALL_GRASP_NEIGHBORS multicast address</dt>
        <dd>(IPv4): 224.0.0.119
          Assigned in the IPv4 Multicast Local Network Control Block.
          <!-- <vspace blankLines="1"/>
          (Note in draft: alternatively, we could use 224.0.0.1, currently
          defined as All Systems on this Subnet.)-->
        </dd>
      </dl>
      <t><xref target="Constants" format="default"/> explains the following User Port,
       which IANA has assigned for use by GRASP for both UDP and TCP:</t>
       
      <dl newline="false" spacing="normal"> 
      <dt>GRASP_LISTEN_PORT:</dt> <dd>7017</dd>
           
      <dt>Service Name:</dt> <dd>Generic Autonomic Signaling Protocol (GRASP)</dd>
           
      <dt>Transport Protocols:</dt> <dd>UDP, TCP</dd>
           
      <dt>Assignee:</dt> <dd>iesg@ietf.org</dd>
           
      <dt>Contact:</dt> <dd>chair@ietf.org</dd>
           
      <dt>Description:</dt> <dd>See <xref target="Constants" format="default"/></dd>
      <dt>Reference:</dt> <dd>RFC XXXX (this document)<xref target="Constants" format="default"/></dd>
      </dl>
      
      <t>The IANA is requested to create a GRASP Parameter Registry
      including two registry tables. These are the GRASP Messages and Options Table and 
      the GRASP Objective Names Table.</t>
      <t>GRASP Messages and Options Table. The values in this table are names paired with decimal
      integers. Future values MUST be assigned using the Standards Action policy
      defined by <xref target="RFC8126" format="default"/>. The following initial values are assigned by this document:</t>
      <artwork name="" type="" align="left" alt=""><![CDATA[M_NOOP = 0
M_DISCOVERY = 1
M_RESPONSE = 2
M_REQ_NEG = 3
M_REQ_SYN = 4
M_NEGOTIATE = 5
M_END = 6
M_WAIT = 7
M_SYNCH = 8
M_FLOOD = 9
M_INVALID = 99

O_DIVERT = 100
O_ACCEPT = 101
O_DECLINE = 102
O_IPv6_LOCATOR = 103
O_IPv4_LOCATOR = 104
O_FQDN_LOCATOR = 105
O_URI_LOCATOR = 106
]]></artwork>
      <t>GRASP Objective Names Table. The values in this table are UTF-8 strings which
        MUST NOT include a colon (":"), according to <xref target="ObjForm" format="default"/>.
        Future values MUST be assigned using the Specification Required policy
        defined by <xref target="RFC8126" format="default"/>.</t>
      <t>To assist expert review of a new objective, the specification should include
        a precise description of the format of the new objective, with sufficient explanation
        of its semantics to allow independent implementations. See <xref target="ConsOption" format="default"/> for
        more details. If the new objective is similar in name or purpose to a previously 
        registered objective, the specification should explain why a new objective is justified. </t>
      <t>The following initial values are assigned by this document:</t>
      <artwork name="" type="" align="left" alt=""><![CDATA[ EX0
 EX1
 EX2
 EX3
 EX4
 EX5
 EX6
 EX7
 EX8
 EX9
]]></artwork>
    </section>
    <section anchor="ack" numbered="true" toc="default">
      <name>Acknowledgements</name>
      <t>A major contribution to the original version of this document was made by Sheng Jiang
      and significant contributions were made by Toerless Eckert.
      Significant early review inputs were received from Joel Halpern, Barry Leiba,
      Charles E. Perkins, and Michael Richardson. William Atwood provided important assistance in
      debugging a prototype implementation.</t>
      <t>Valuable comments were received from
      Michael Behringer,
      Jeferson Campos Nobre,
      Laurent Ciavaglia,
      Zongpeng Du,
      Yu Fu,
      Joel Jaeggli,
      Zhenbin Li,
      Dimitri Papadimitriou,
      Pierre Peloso,
      Reshad Rahman,
      Markus Stenberg,
      Martin Stiemerling,
      Rene Struik,
      Martin Thomson,
      Dacheng Zhang,
      and participants in the NMRG research group,
      the ANIMA working group,
      and the IESG.</t>
    </section>
  </middle>
  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <!-- <?rfc include='reference.RFC.5280'?> -->
      <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4086.xml"/>
        <!-- <?rfc include='reference.RFC.5246'?> -->
      <!-- <?rfc include='reference.RFC.6347'?> -->
      <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3986.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7049.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7217.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3629.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8085.xml"/>
      <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-anima-autonomic-control-plane.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8610.xml"/>
      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2334.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3493.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6733.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2865.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4861.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5971.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6241.xml"/>
        <!-- <?rfc include='reference.RFC.3209'?> -->
      <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2205.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3416.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3315.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6887.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6762.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6763.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2608.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6206.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7564.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7575.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7576.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7558.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7787.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7788.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8040.xml"/>
      <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-anima-grasp-api.xml"/>
      <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.stenberg-anima-adncp.xml"/>
      <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.chaparadza-intarea-igcp.xml"/>
      <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-anima-reference-model.xml"/>
      <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-anima-bootstrapping-keyinfra.xml"/>
      <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8368.xml"/>
      <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5612.xml"/>
      <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.carpenter-anima-asa-guidelines.xml"/>
      </references>
    </references>
 
    <section anchor="examples" numbered="true" toc="default">
      <name>Example Message Formats</name>
      <t>For readers unfamiliar with CBOR, this appendix shows a number of example GRASP 
      messages conforming to the CDDL syntax given
      in  <xref target="cddl" format="default"/>. Each message is shown three times in the following formats:
      </t>
      <ol spacing="normal" type="1">
        <li>CBOR diagnostic notation.</li>
        <li>Similar, but showing the names of the constants. (Details of the flag bit encoding are omitted.) </li>
        <li>Hexadecimal version of the CBOR wire format.</li>
      </ol>
      <t>
      Long lines are split for display purposes only.</t>
      <section numbered="true" toc="default">
        <name>Discovery Example</name>
        <t>The initiator (2001:db8:f000:baaa:28cc:dc4c:9703:6781) multicasts a discovery message
looking for objective EX1:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
[1, 13948744, h'20010db8f000baaa28ccdc4c97036781', ["EX1", 5, 2, 0]]
[M_DISCOVERY, 13948744, h'20010db8f000baaa28ccdc4c97036781',
              ["EX1", F_SYNCH_bits, 2, 0]]
h'84011a00d4d7485020010db8f000baaa28ccdc4c970367818463455831050200' 
]]></artwork>
        <t>A peer (2001:0db8:f000:baaa:f000:baaa:f000:baaa) responds with a locator:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
[2, 13948744, h'20010db8f000baaa28ccdc4c97036781', 60000,
              [103, h'20010db8f000baaaf000baaaf000baaa', 6, 49443]] 
[M_RESPONSE, 13948744, h'20010db8f000baaa28ccdc4c97036781', 60000,
              [O_IPv6_LOCATOR, h'20010db8f000baaaf000baaaf000baaa',
               IPPROTO_TCP, 49443]]
h'85021a00d4d7485020010db8f000baaa28ccdc4c9703678119ea6084186750
  20010db8f000baaaf000baaaf000baaa0619c123' 
]]></artwork>
      </section>
      <section numbered="true" toc="default">
        <name>Flood Example</name>
        <t>The initiator multicasts a flood message. The single objective has a null locator. There is no response:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
[9, 3504974, h'20010db8f000baaa28ccdc4c97036781', 10000,  
             [["EX1", 5, 2, ["Example 1 value=", 100]],[] ] ] 
[M_FLOOD, 3504974, h'20010db8f000baaa28ccdc4c97036781', 10000,
             [["EX1", F_SYNCH_bits, 2, ["Example 1 value=", 100]],[] ] ]
h'86091a00357b4e5020010db8f000baaa28ccdc4c97036781192710
  828463455831050282704578616d706c6520312076616c75653d186480'  
]]></artwork>
      </section>
      <section numbered="true" toc="default">
        <name>Synchronization Example</name>
        <t>Following successful discovery of objective EX2, the initiator unicasts a request:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
[4, 4038926, ["EX2", 5, 5, 0]] 
[M_REQ_SYN, 4038926, ["EX2", F_SYNCH_bits, 5, 0]] 
h'83041a003da10e8463455832050500'
]]></artwork>
        <t>The peer responds with a value:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
[8, 4038926, ["EX2", 5, 5, ["Example 2 value=", 200]]] 
[M_SYNCH, 4038926, ["EX2", F_SYNCH_bits, 5, ["Example 2 value=", 200]]] 
h'83081a003da10e8463455832050582704578616d706c6520322076616c75653d18c8' 
]]></artwork>
      </section>
      <section numbered="true" toc="default">
        <name>Simple Negotiation Example</name>
        <t>Following successful discovery of objective EX3, the initiator unicasts a request:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
[3, 802813, ["EX3", 3, 6, ["NZD", 47]]] 
[M_REQ_NEG, 802813, ["EX3", F_NEG_bits, 6, ["NZD", 47]]] 
h'83031a000c3ffd8463455833030682634e5a44182f' 
]]></artwork>
        <t>The peer responds with immediate acceptance. Note that no objective is needed,
because the initiator's request was accepted without change:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
[6, 802813, [101]] 
[M_END , 802813, [O_ACCEPT]]
h'83061a000c3ffd811865' 
]]></artwork>
      </section>
      <section numbered="true" toc="default">
        <name>Complete Negotiation Example</name>
        <t>Again the initiator unicasts a request:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
[3, 13767778, ["EX3", 3, 6, ["NZD", 410]]] 
[M_REQ_NEG, 13767778, ["EX3", F_NEG_bits, 6, ["NZD", 410]]]
h'83031a00d214628463455833030682634e5a4419019a' 
]]></artwork>
        <t>The responder starts to negotiate (making an offer):</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
[5, 13767778, ["EX3", 3, 6, ["NZD", 80]]] 
[M_NEGOTIATE, 13767778, ["EX3", F_NEG_bits, 6, ["NZD", 80]]] 
h'83051a00d214628463455833030682634e5a441850' 
]]></artwork>
        <t>The initiator continues to negotiate (reducing its request, and note that the loop count is decremented):</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
[5, 13767778, ["EX3", 3, 5, ["NZD", 307]]] 
[M_NEGOTIATE, 13767778, ["EX3", F_NEG_bits, 5, ["NZD", 307]]] 
h'83051a00d214628463455833030582634e5a44190133' 
]]></artwork>
        <t>The responder asks for more time:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
[7, 13767778, 34965] 
[M_WAIT, 13767778, 34965] 
h'83071a00d21462198895' 
]]></artwork>
        <t>The responder continues to negotiate (increasing its offer):</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
[5, 13767778, ["EX3", 3, 4, ["NZD", 120]]] 
[M_NEGOTIATE, 13767778, ["EX3", F_NEG_bits, 4, ["NZD", 120]]]
h'83051a00d214628463455833030482634e5a441878' 
]]></artwork>
        <t>The initiator continues to negotiate (reducing its request):</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
[5, 13767778, ["EX3", 3, 3, ["NZD", 246]]] 
[M_NEGOTIATE, 13767778, ["EX3", F_NEG_bits, 3, ["NZD", 246]]]
h'83051a00d214628463455833030382634e5a4418f6' 
]]></artwork>
        <t>The responder refuses to negotiate further:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
[6, 13767778, [102, "Insufficient funds"]] 
[M_END , 13767778, [O_DECLINE, "Insufficient funds"]] 
h'83061a00d2146282186672496e73756666696369656e742066756e6473' 
]]></artwork>
        <t>This negotiation has failed. If either side had sent
[M_END, 13767778, [O_ACCEPT]] it would have succeeded, converging
on the objective value in the preceding M_NEGOTIATE. Note that apart
from the initial M_REQ_NEG, the process is symmetrical.</t>
      </section>
    </section>
    <section anchor="reqts" numbered="true" toc="default">
      <name>Requirement Analysis of Discovery, Synchronization and Negotiation</name>
      <t>This section discusses the requirements for discovery, negotiation
      and synchronization capabilities. The primary user of the protocol is an autonomic service
      agent (ASA), so the requirements are mainly expressed as the features needed by an ASA.
      A single physical device might contain several ASAs, and a single ASA might manage
      several technical objectives. If a technical objective is managed by several ASAs,
      any necessary coordination is outside the scope of the GRASP signaling protocol.
      Furthermore, requirements for ASAs themselves, such as the processing of Intent 
      <xref target="RFC7575" format="default"/>, are out of scope for the present document.</t>
      <section numbered="true" toc="default">
        <name>Requirements for Discovery</name>
        <t>D1. ASAs may be designed to manage any type of configurable device or software,
        as required in <xref target="synchreq" format="default"/>. A basic requirement
        is therefore that the protocol can represent and discover any
        kind of technical objective (as defined in <xref target="terms" format="default"/>)
        among arbitrary subsets of participating nodes.</t>
        <t>In an autonomic network we must assume that when a device starts up
        it has no information about any peer devices, the network structure,
        or what specific role it must play. The ASA(s) inside the device are
        in the same situation. In some cases, when a new application session
        starts up within a device, the device or ASA may again lack
        information about relevant peers. For example, it might be necessary to set
        up resources on multiple other devices, coordinated and matched to
        each other so that there is no wasted resource. Security settings
        might also need updating to allow for the new device or user. 
        The relevant peers may be different for different technical
        objectives. Therefore discovery needs to be repeated as often as
        necessary to find peers capable of acting as counterparts for each
        objective that a discovery initiator needs to handle.
        From this background we derive the next three requirements:</t>
        <t>D2. When an ASA first starts up, it may have no knowledge of the specific network to
        which it is attached.
        Therefore the discovery process must be able to support any network scenario,
        assuming only that the device concerned is bootstrapped from factory condition.
        </t>
        <t>D3. When an ASA starts up, it must require no configured location information about any
        peers in order to discover them.</t>
        <t>D4. If an ASA supports multiple technical objectives, relevant peers may be different
        for different discovery objectives, so discovery needs to be performed separately to
        find counterparts for each objective. Thus, there must be a mechanism by
        which an ASA can separately discover peer ASAs for each of the
        technical objectives that it needs to manage, whenever necessary.</t>
        <t>D5. Following discovery, an ASA will normally perform negotiation
        or synchronization for the corresponding objectives. The design
        should allow for this by conveniently linking discovery to negotiation
        and synchronization. It may provide an optional mechanism to
        combine discovery and negotiation/synchronization in a single protocol exchange.</t>
        <t>D6. Some objectives may only be significant on the local link,
        but others may be significant across the routed network and require
        off-link operations. Thus, the relevant peers might be immediate
        neighbors on the same layer 2 link, or they might be more distant and
        only accessible via layer 3. The mechanism must therefore provide both
        on-link and off-link discovery of ASAs supporting specific technical
        objectives.</t>
        <t>D7. The discovery process should be flexible enough to allow for
        special cases, such as the following:
 
        </t>
        <ul spacing="normal">
          <li>During initialization, a device must be able to establish mutual trust
        with autonomic nodes elsewhere in the network and participate in an
        authentication mechanism. Although
        this will inevitably start with a discovery action, it is a special case
        precisely because trust is not yet established. This topic
        is the subject of <xref target="I-D.ietf-anima-bootstrapping-keyinfra" format="default"/>.
        We require that once trust has been established for a device,
        all ASAs within the device inherit the device's credentials and are also trusted.
        This does not preclude the device having multiple credentials.</li>
          <li>
        Depending on the type of network involved, discovery of other
        central functions might be needed, such as
        the Network Operations Center (NOC) <xref target="RFC8368" format="default"/>.
        The protocol must be capable of supporting such discovery during initialization,
        as well as discovery during ongoing operation.</li>
        </ul>
        <t>D8. The discovery process must not generate excessive traffic and 
        must take account of sleeping nodes. </t>
        <t>D9. There must be a mechanism for handling stale discovery results.</t>
      </section>
      <section anchor="synchreq" numbered="true" toc="default">
        <name>Requirements for Synchronization and Negotiation Capability</name>
        <!--<t>As background, consider the example of routing protocols, the closest
        approximation to autonomic networking already in widespread use. Routing
        protocols use a largely autonomic model based on distributed devices
        that communicate repeatedly with each other. The focus
        is reachability, so routing protocols primarily consider simple
        link status and metrics, and an underlying assumption is that
        nodes need a consistent, although partial, view of the network topology
        in order for the routing algorithm to converge. Also, routing is
        mainly based on simple information synchronization between peers,
        rather than on bi-directional negotiation.</t>-->
        <t>Autonomic networks need to be able to manage many
        different types of parameter and consider many dimensions,
        such as latency, load, unused or limited resources,
        conflicting resource requests,
        security settings, power saving, load balancing, etc. 
        Status information and resource metrics need to be shared between
        nodes for dynamic adjustment of resources and for monitoring purposes.
        While this might be achieved by existing protocols when they are
        available, the new protocol needs to be able to support parameter
        exchange, including mutual synchronization, even when no negotiation
        as such is required. In general, these parameters do not apply to all
        participating nodes, but only to a subset. </t>
        <t>SN1. A basic requirement for the protocol is therefore the
        ability to represent, discover, synchronize and negotiate almost any
        kind of network parameter among selected subsets of participating nodes.</t>
        <t>SN2. Negotiation is an iterative request/response process that must be guaranteed to terminate 
        (with success or failure). While tie-breaking rules must be defined specifically 
        for each use case, the protocol should have some general mechanisms in support of loop
        and deadlock prevention, such as hop count limits or timeouts.</t>
        <t>SN3. Synchronization must be possible for groups of nodes ranging from small to very large.
        </t>
        <t>SN4. To avoid "reinventing the wheel", the protocol should be able to encapsulate the
        data formats used by existing configuration protocols (such as NETCONF/YANG)
        in cases where that is convenient.</t>
        <t>SN5. Human intervention in complex situations is costly and error-prone.
        Therefore, synchronization or negotiation of parameters without human
        intervention is desirable whenever the coordination of multiple devices can improve
        overall network performance. It follows that the protocol's resource requirements
        must be small enough to fit in any device that would otherwise need human intervention.
        The issue of running in constrained nodes
        is discussed in <xref target="I-D.ietf-anima-reference-model" format="default"/>.</t>
        <t>SN6. Human intervention in large networks is often replaced by use of a
        top-down network management system (NMS). It therefore follows that 
        the protocol, as part of the Autonomic Networking Infrastructure, should
        be capable of running in any device that would otherwise be managed by 
        an NMS, and that it can co-exist with an NMS, and with protocols
        such as SNMP and NETCONF.</t>
        <t>SN7. Specific autonomic features are expected to be implemented by individual ASAs,
        but the protocol must be general enough to allow them. Some examples follow: 
        </t>
        <ul spacing="normal">
          <li>Dependencies and conflicts: In order to
          decide upon a configuration for a given device, the device may need
          information from neighbors. This can be established through the
          negotiation procedure, or through synchronization if that
          is sufficient. However, a given item in a neighbor
          may depend on other information from its own neighbors, which may
          need another negotiation or synchronization procedure to obtain or decide.
          Therefore, there are potential dependencies and conflicts among negotiation or synchronization
          procedures. Resolving dependencies and conflicts is a matter for the individual ASAs involved. 
          To allow this, there need to be clear boundaries and convergence
          mechanisms for negotiations. Also some mechanisms are needed to avoid
          loop dependencies or uncontrolled growth in a tree of dependencies.
          It is the ASA designer's responsibility
          to avoid or detect looping dependencies or excessive growth of dependency trees.
          The protocol's role is limited to bilateral signaling between ASAs,
          and the avoidance of loops during bilateral signaling.</li>
          <li>Recovery from faults and identification of faulty devices should be
          as automatic as possible. The protocol's role is limited to discovery, synchronization and
          negotiation. These processes can occur at any time, and an ASA may
          need to repeat any of these steps when the ASA detects an event
          such as a negotiation counterpart failing.</li>
          <li>Since a major goal is to minimize human intervention, it is necessary that the
          network can in effect "think ahead" before changing its parameters. One aspect
          of this is an ASA that relies on a knowledge base to predict network behavior.
          This is out of scope for the signaling protocol. However, another aspect is
          forecasting the effect of a change by a "dry run" negotiation before actually
          installing the change. Signaling a dry run is therefore a desirable feature
          of the protocol. </li>
        </ul>
        <t>Note that management logging, monitoring, alerts and tools for intervention are required.
          However, these can only be features of individual ASAs, not of the protocol itself. 
          Another document <xref target="RFC8368" format="default"/> discusses how
          such agents may be linked into conventional OAM systems via an Autonomic Control Plane
          <xref target="I-D.ietf-anima-autonomic-control-plane" format="default"/>. </t>
        <t>SN8. The protocol will be able to deal with a wide variety of
        technical objectives, covering any type of network parameter.
        Therefore the protocol will need a flexible and easily extensible format for
        describing objectives. At a later stage it may be desirable to adopt an explicit
        information model. One consideration is whether to adopt an existing
        information model or to design a new one. </t>
      </section>
      <section numbered="true" toc="default">
        <name>Specific Technical Requirements</name>
        <t>T1. It should be convenient for ASA designers to define new technical objectives
        and for programmers to express them, without excessive impact on
        run-time efficiency and footprint. In particular, it should be convenient for ASAs
        to be implemented independently of each other as user space programs rather than as kernel
        code, where such a programming model is possible. The classes of device in which the protocol
        might run is discussed in <xref target="I-D.ietf-anima-reference-model" format="default"/>.
        </t>
        <t>T2. The protocol should be easily extensible in case the initially defined discovery,
        synchronization and negotiation mechanisms prove to be insufficient. </t>
        <t>T3. To be a generic platform, the protocol payload format should be 
        independent of the transport protocol or IP version.
        In particular, it should be able to run over IPv6 or IPv4.
        However, some functions, such as multicasting on
        a link, might need to be IP version dependent. By default, IPv6 should
        be preferred.</t>
        <t>T4. The protocol must be able to access off-link counterparts via routable addresses,
        i.e., must not be restricted to link-local operation.</t>
        <t>T5. It must also be possible for an external discovery mechanism
        to be used, if appropriate for a given technical objective. In other words, GRASP discovery
        must not be a prerequisite for GRASP negotiation or synchronization. </t>
        <t>T6. The protocol must be capable of distinguishing multiple simultaneous
        operations with one or more peers, especially when wait states occur.</t>
        <t>T7. Intent: Although the distribution of Intent is out of scope
        for this document, the protocol must not by design exclude its
        use for Intent distribution. </t>
        <t>T8. Management monitoring, alerts and intervention:
        Devices should be able to report to a monitoring
        system. Some events must be able to generate operator alerts and
        some provision for emergency intervention must be possible (e.g.
        to freeze synchronization or negotiation in a mis-behaving device). These features
        might not use the signaling protocol itself, but its design should not exclude such use.</t>
        <t>T9. Because this protocol may directly cause changes to device configurations 
        and have significant impacts on a running network, all protocol exchanges need to be
        fully secured against forged messages and man-in-the middle attacks, and secured
        as much as reasonably possible against denial of service attacks. There must also
        be an encryption mechanism to resist unwanted monitoring. However, it is not required
        that the protocol itself provides these security features; it may depend on an existing
        secure environment. </t>
      </section>
    </section>
    <!-- reqts -->

   
    
 <section anchor="current" numbered="true" toc="default">
      <name>Capability Analysis of Current Protocols</name>
      <t>This appendix discusses various existing protocols with properties
      related to the requirements described in <xref target="reqts" format="default"/>. The
      purpose is to evaluate whether any existing protocol, or a simple
      combination of existing protocols, can meet those requirements.</t>
      <t>Numerous protocols include some form of discovery, but these all appear to be very
      specific in their applicability. Service Location Protocol (SLP) 
      <xref target="RFC2608" format="default"/> provides service discovery for managed networks,
      but requires configuration of its own servers. DNS-SD <xref target="RFC6763" format="default"/>
      combined with mDNS <xref target="RFC6762" format="default"/> provides service discovery for
      small networks with a single link layer. <xref target="RFC7558" format="default"/>
      aims to extend this to larger autonomous networks but this is not yet
      standardized. However, both SLP and DNS-SD appear to
      target primarily application layer services, not the layer 2 and 3 objectives
      relevant to basic network configuration. Both SLP and DNS-SD are text-based protocols. </t>
      <!-- <t>Routing protocols are mainly one-way information announcements. The
      receiver makes independent decisions based on the received information
      and there is no direct feedback information to the announcing peer. This
      remains true even though the protocol is used in both directions between
      peer routers; there is state synchronization, but no negotiation, and
      each peer runs its route calculations independently.</t>-->

      <t>Simple Network Management Protocol (SNMP) <xref target="RFC3416" format="default"/> uses
      a command/response model not well suited for peer negotiation. Network Configuration
      Protocol (NETCONF) <xref target="RFC6241" format="default"/> uses an RPC model that does allow positive or
      negative responses from the target system, but this is still not
      adequate for negotiation.</t>
      <t>There are various existing protocols that have elementary negotiation
      abilities, such as Dynamic Host Configuration Protocol for IPv6 (DHCPv6)
      <xref target="RFC3315" format="default"/>, Neighbor Discovery (ND) <xref target="RFC4861" format="default"/>,
      Port Control Protocol (PCP) <xref target="RFC6887" format="default"/>, Remote Authentication
      Dial In User Service (RADIUS) <xref target="RFC2865" format="default"/>, Diameter <xref target="RFC6733" format="default"/>,
      etc. Most of them are configuration or
      management protocols. However, they either provide only a simple
      request/response model in a master/slave context or very limited
      negotiation abilities.</t>
      <t>There are some signaling protocols with an element of negotiation.
      For example Resource ReSerVation Protocol (RSVP) <xref target="RFC2205" format="default"/>
      was designed for negotiating quality of service
      parameters along the path of a unicast or multicast flow. RSVP is a very
      specialised protocol aimed at end-to-end flows. <!--However, it has some
      flexibility, having been adapted for MPLS label distribution (RSVP-TE, <xref target="RFC3209"/>).-->
      A more generic design is General Internet
      Signalling Transport (GIST) <xref target="RFC5971" format="default"/>, but it is
      complex, tries to solve many problems, and is also aimed at per-flow
      signaling across many hops rather than at device-to-device signaling.
      However, we cannot completely exclude extended RSVP or GIST as a
      synchronization and negotiation protocol. They do not appear to be
      directly useable for peer discovery.</t>
      <t>RESTCONF <xref target="RFC8040" format="default"/> is a protocol intended to
      convey NETCONF information expressed in the YANG language via HTTP,
      including the ability to transit HTML intermediaries. While this is a
      powerful approach in the context of centralised configuration of a
      complex network, it is not well adapted to efficient interactive
      negotiation between peer devices, especially simple ones that might
      not include YANG processing already.</t>
      <t>The Distributed Node Consensus Protocol (DNCP) 
      <xref target="RFC7787" format="default"/> is defined as a generic form
      of state synchronization protocol, with a proposed usage profile being the 
      Home Networking Control Protocol (HNCP) <xref target="RFC7788" format="default"/>
      for configuring Homenet routers. A specific application of DNCP for autonomic
      networking was proposed in <xref target="I-D.stenberg-anima-adncp" format="default"/>.
      </t>
      <t>DNCP "is designed to provide a way for each participating node to
         publish a set of TLV (Type-Length-Value) tuples, and to provide a
         shared and common view about the data published... DNCP is most suitable
         for data that changes only infrequently... If constant rapid
         state changes are needed, the preferable choice is to use an
         additional point-to-point channel..."</t>
      <t>Specific features of DNCP include:
      </t>
      <ul spacing="normal">
        <li>Every participating node has a unique node identifier.</li>
        <li>DNCP messages are encoded as a sequence of TLV objects, sent over
          unicast UDP or TCP, with or without (D)TLS security.</li>
        <li>Multicast is used only for discovery of DNCP neighbors
          when lower security is acceptable.</li>
        <li>Synchronization of state is maintained by a flooding process using the Trickle algorithm.
          There is no bilateral synchronization or negotiation capability.</li>
        <li>The HNCP profile of DNCP is designed to operate between directly connected neighbors
          on a shared link using UDP and link-local IPv6 addresses.</li>
      </ul>
      <t>
      DNCP does not meet the needs of a general negotiation protocol, because it is designed
      specifically for flooding synchronization. Also, in its HNCP profile it is limited to link-local
      messages and to IPv6. However, at the minimum it is a
      very interesting test case for this style of interaction between devices
      without needing a central authority, and it is a proven method of network-wide state
      synchronization by flooding.</t>
      <t>The Server Cache Synchronization Protocol (SCSP) <xref target="RFC2334" format="default"/> also describes
      a method for cache synchronization and cache replication among a group of nodes.</t>
      <t>A proposal was made some years ago for an IP based Generic Control Protocol
      (IGCP) <xref target="I-D.chaparadza-intarea-igcp" format="default"/>. This was aimed
      at information exchange and negotiation but not directly at peer
      discovery. However, it has many points in common with the present work.</t>
      <t>None of the above solutions appears to completely meet the needs of
      generic discovery, state synchronization and negotiation in a single solution.
      Many of the protocols assume that they are working in a traditional
      top-down or north-south scenario, rather than a fluid peer-to-peer
      scenario. Most of them are specialized in one way or another. As a result, 
      we have not identified a combination of existing protocols that meets the
      requirements in <xref target="reqts" format="default"/>. Also, we have not identified a path
      by which one of the existing protocols could be extended to meet the
      requirements.
      </t>
    </section>
    <!-- current -->
    
  </back>
</rfc>
