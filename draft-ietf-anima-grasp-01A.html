<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>A Generic Autonomic Signaling Protocol (GRASP)</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Requirement Analysis of Discovery, Synchronization and Negotiation"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Requirements for Discovery"/>
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Requirements for Synchronization and Negotiation Capability"/>
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Specific Technical Requirements"/>
<link href="#rfc.section.3" rel="Chapter" title="3 GRASP Protocol Overview"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Terminology"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 High-Level Design Choices"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 GRASP Protocol Basic Properties and Mechanisms"/>
<link href="#rfc.section.3.3.1" rel="Chapter" title="3.3.1 Required External Security Mechanism"/>
<link href="#rfc.section.3.3.2" rel="Chapter" title="3.3.2 Transport Layer Usage"/>
<link href="#rfc.section.3.3.3" rel="Chapter" title="3.3.3 Discovery Mechanism and Procedures"/>
<link href="#rfc.section.3.3.4" rel="Chapter" title="3.3.4 Negotiation Procedures"/>
<link href="#rfc.section.3.3.5" rel="Chapter" title="3.3.5 Synchronization Procedure"/>
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 High Level Deployment Model"/>
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 GRASP Constants"/>
<link href="#rfc.section.3.6" rel="Chapter" title="3.6 Session Identifier (Session ID)"/>
<link href="#rfc.section.3.7" rel="Chapter" title="3.7 GRASP Messages"/>
<link href="#rfc.section.3.7.1" rel="Chapter" title="3.7.1 GRASP Message Format"/>
<link href="#rfc.section.3.7.2" rel="Chapter" title="3.7.2 Discovery Message"/>
<link href="#rfc.section.3.7.3" rel="Chapter" title="3.7.3 Response Message"/>
<link href="#rfc.section.3.7.4" rel="Chapter" title="3.7.4 Request Message"/>
<link href="#rfc.section.3.7.5" rel="Chapter" title="3.7.5 Negotiation Message"/>
<link href="#rfc.section.3.7.6" rel="Chapter" title="3.7.6 Negotiation-ending Message"/>
<link href="#rfc.section.3.7.7" rel="Chapter" title="3.7.7 Confirm-waiting Message"/>
<link href="#rfc.section.3.8" rel="Chapter" title="3.8 GRASP General Options"/>
<link href="#rfc.section.3.8.1" rel="Chapter" title="3.8.1 Format of GRASP Options"/>
<link href="#rfc.section.3.8.2" rel="Chapter" title="3.8.2 Divert Option"/>
<link href="#rfc.section.3.8.3" rel="Chapter" title="3.8.3 Accept Option"/>
<link href="#rfc.section.3.8.4" rel="Chapter" title="3.8.4 Decline Option"/>
<link href="#rfc.section.3.8.5" rel="Chapter" title="3.8.5 Waiting Time Option"/>
<link href="#rfc.section.3.8.6" rel="Chapter" title="3.8.6 Device Identity Option"/>
<link href="#rfc.section.3.8.7" rel="Chapter" title="3.8.7 Locator Options"/>
<link href="#rfc.section.3.9" rel="Chapter" title="3.9 Objective Options"/>
<link href="#rfc.section.3.9.1" rel="Chapter" title="3.9.1 Format of Objective Options"/>
<link href="#rfc.section.3.9.2" rel="Chapter" title="3.9.2 Objective flags"/>
<link href="#rfc.section.3.9.3" rel="Chapter" title="3.9.3 General Considerations for Objective Options"/>
<link href="#rfc.section.3.9.4" rel="Chapter" title="3.9.4 Organizing of Objective Options"/>
<link href="#rfc.section.3.9.5" rel="Chapter" title="3.9.5 Experimental and Example Objective Options"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Open Issues"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Security Considerations"/>
<link href="#rfc.section.6" rel="Chapter" title="6 CDDL Specification of GRASP"/>
<link href="#rfc.section.7" rel="Chapter" title="7 IANA Considerations"/>
<link href="#rfc.section.8" rel="Chapter" title="8 Acknowledgements"/>
<link href="#rfc.section.9" rel="Chapter" title="9 Change log [RFC Editor: Please remove]"/>
<link href="#rfc.references" rel="Chapter" title="10 References"/>
<link href="#rfc.references.1" rel="Chapter" title="10.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="10.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Capability Analysis of Current Protocols"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.1.dev0 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Bormann, C., Carpenter, B., Ed., and B. Liu, Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-anima-grasp-01" />
  <meta name="dct.issued" scheme="ISO8601" content="2015-9-25" />
  <meta name="dct.abstract" content="This document establishes requirements for a signaling protocol that enables autonomic devices and autonomic service agents to dynamically discover peers, to synchronize state with them, and to negotiate parameter settings mutually with them. The document then defines a general protocol for discovery, synchronization and negotiation, while the technical objectives for specific scenarios are to be described in separate documents. An Appendix briefly discusses existing protocols with comparable features." />
  <meta name="description" content="This document establishes requirements for a signaling protocol that enables autonomic devices and autonomic service agents to dynamically discover peers, to synchronize state with them, and to negotiate parameter settings mutually with them. The document then defines a general protocol for discovery, synchronization and negotiation, while the technical objectives for specific scenarios are to be described in separate documents. An Appendix briefly discusses existing protocols with comparable features." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">Network Working Group</td>
  <td class="right">C. Bormann</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Universit&#228;t Bremen TZI</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">B. Carpenter, Ed.</td>
</tr>
<tr>
  <td class="left">Expires: March 28, 2016</td>
  <td class="right">Univ. of Auckland</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">B. Liu, Ed.</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">Huawei Technologies Co., Ltd</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">September 25, 2015</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">A Generic Autonomic Signaling Protocol (GRASP)<br />
  <span class="filename">draft-ietf-anima-grasp-01</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document establishes requirements for a signaling protocol that enables autonomic devices and autonomic service agents to dynamically discover peers, to synchronize state with them, and to negotiate parameter settings mutually with them. The document then defines a general protocol for discovery, synchronization and negotiation, while the technical objectives for specific scenarios are to be described in separate documents. An Appendix briefly discusses existing protocols with comparable features.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on March 28, 2016.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2015 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Requirement Analysis of Discovery, Synchronization and Negotiation</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Requirements for Discovery</a></li>
<li>2.2.   <a href="#rfc.section.2.2">Requirements for Synchronization and Negotiation Capability</a></li>
<li>2.3.   <a href="#rfc.section.2.3">Specific Technical Requirements</a></li>
</ul><li>3.   <a href="#rfc.section.3">GRASP Protocol Overview</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Terminology</a></li>
<li>3.2.   <a href="#rfc.section.3.2">High-Level Design Choices</a></li>
<li>3.3.   <a href="#rfc.section.3.3">GRASP Protocol Basic Properties and Mechanisms</a></li>
<ul><li>3.3.1.   <a href="#rfc.section.3.3.1">Required External Security Mechanism</a></li>
<li>3.3.2.   <a href="#rfc.section.3.3.2">Transport Layer Usage</a></li>
<li>3.3.3.   <a href="#rfc.section.3.3.3">Discovery Mechanism and Procedures</a></li>
<li>3.3.4.   <a href="#rfc.section.3.3.4">Negotiation Procedures</a></li>
<li>3.3.5.   <a href="#rfc.section.3.3.5">Synchronization Procedure</a></li>
</ul><li>3.4.   <a href="#rfc.section.3.4">High Level Deployment Model</a></li>
<li>3.5.   <a href="#rfc.section.3.5">GRASP Constants</a></li>
<li>3.6.   <a href="#rfc.section.3.6">Session Identifier (Session ID)</a></li>
<li>3.7.   <a href="#rfc.section.3.7">GRASP Messages</a></li>
<ul><li>3.7.1.   <a href="#rfc.section.3.7.1">GRASP Message Format</a></li>
<li>3.7.2.   <a href="#rfc.section.3.7.2">Discovery Message</a></li>
<li>3.7.3.   <a href="#rfc.section.3.7.3">Response Message</a></li>
<li>3.7.4.   <a href="#rfc.section.3.7.4">Request Message</a></li>
<li>3.7.5.   <a href="#rfc.section.3.7.5">Negotiation Message</a></li>
<li>3.7.6.   <a href="#rfc.section.3.7.6">Negotiation-ending Message</a></li>
<li>3.7.7.   <a href="#rfc.section.3.7.7">Confirm-waiting Message</a></li>
</ul><li>3.8.   <a href="#rfc.section.3.8">GRASP General Options</a></li>
<ul><li>3.8.1.   <a href="#rfc.section.3.8.1">Format of GRASP Options</a></li>
<li>3.8.2.   <a href="#rfc.section.3.8.2">Divert Option</a></li>
<li>3.8.3.   <a href="#rfc.section.3.8.3">Accept Option</a></li>
<li>3.8.4.   <a href="#rfc.section.3.8.4">Decline Option</a></li>
<li>3.8.5.   <a href="#rfc.section.3.8.5">Waiting Time Option</a></li>
<li>3.8.6.   <a href="#rfc.section.3.8.6">Device Identity Option</a></li>
<li>3.8.7.   <a href="#rfc.section.3.8.7">Locator Options</a></li>
</ul><li>3.9.   <a href="#rfc.section.3.9">Objective Options</a></li>
<ul><li>3.9.1.   <a href="#rfc.section.3.9.1">Format of Objective Options</a></li>
<li>3.9.2.   <a href="#rfc.section.3.9.2">Objective flags</a></li>
<li>3.9.3.   <a href="#rfc.section.3.9.3">General Considerations for Objective Options</a></li>
<li>3.9.4.   <a href="#rfc.section.3.9.4">Organizing of Objective Options</a></li>
<li>3.9.5.   <a href="#rfc.section.3.9.5">Experimental and Example Objective Options</a></li>
</ul></ul><li>4.   <a href="#rfc.section.4">Open Issues</a></li>
<li>5.   <a href="#rfc.section.5">Security Considerations</a></li>
<li>6.   <a href="#rfc.section.6">CDDL Specification of GRASP</a></li>
<li>7.   <a href="#rfc.section.7">IANA Considerations</a></li>
<li>8.   <a href="#rfc.section.8">Acknowledgements</a></li>
<li>9.   <a href="#rfc.section.9">Change log [RFC Editor: Please remove]</a></li>
<li>10.   <a href="#rfc.references">References</a></li>
<ul><li>10.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>10.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Capability Analysis of Current Protocols</a></li>
<li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#intro" id="intro">Introduction</a></h1>
<p id="rfc.section.1.p.1">The success of the Internet has made IP-based networks bigger and more complicated. Large-scale ISP and enterprise networks have become more and more problematic for human based management. Also, operational costs are growing quickly.  Consequently, there are increased requirements for autonomic behavior in the networks.  General aspects of autonomic networks are discussed in <a href="#RFC7575">[RFC7575]</a> and <a href="#RFC7576">[RFC7576]</a>.  A reference model for autonomic networking is given in <a href="#I-D.behringer-anima-reference-model">[I-D.behringer-anima-reference-model]</a>.  In order to fulfil autonomy, devices that embody autonomic service agents have specific signaling requirements. In particular they need to discover each other, to synchronize state with each other, and to negotiate parameters and resources directly with each other.  There is no restriction on the type of parameters and resources concerned, which include very basic information needed for addressing and routing, as well as anything else that might be configured in a conventional non-autonomic network.  The atomic unit of synchronization or negotiation is referred to as a technical objective, i.e, a configurable parameter or set of parameters (defined more precisely in <a href="#terms">Section 3.1</a>).</p>
<p id="rfc.section.1.p.2">Following this Introduction, <a href="#reqts">Section 2</a> describes the requirements for discovery, synchronization and negotiation.  Negotiation is an iterative process, requiring multiple message exchanges forming a closed loop between the negotiating devices. State synchronization, when needed, can be regarded as a special case of negotiation, without iteration.  <a href="#highlevel">Section 3.2</a> describes a behavior model for a protocol intended to support discovery, synchronization and negotiation. The design of GeneRic Autonomic Signaling Protocol (GRASP) in <a href="#Overview">Section 3</a> of this document is mainly based on this behavior model. The relevant capabilities of various existing protocols are reviewed in <a href="#current">Appendix A</a>.</p>
<p id="rfc.section.1.p.3">The proposed discovery mechanism is oriented towards synchronization and negotiation objectives. It is based on a neighbor discovery process, but also supports diversion to off-link peers. Although many negotiations will occur between horizontally distributed peers, many target scenarios are hierarchical networks, which is the predominant structure of current large-scale managed networks.  However, when a device starts up with no pre-configuration, it has no knowledge of the topology. The protocol itself is capable of being used in a small and/or flat network structure such as a small office or home network as well as a professionally managed network.  Therefore, the discovery mechanism needs to be able to allow a device to bootstrap itself without making any prior assumptions about network structure. </p>
<p id="rfc.section.1.p.4">Because GRASP can be used to perform a decision process among distributed devices or between networks, it must run in a secure and strongly authenticated environment.  </p>
<p id="rfc.section.1.p.5">It is understood that in realistic deployments, not all devices will support GRASP. It is expected that some autonomic service agents will directly manage a group of non-autonomic nodes, and that other non-autonomic nodes will be managed traditionally. Such mixed scenarios are not discussed in this specification.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#reqts" id="reqts">Requirement Analysis of Discovery, Synchronization and Negotiation</a></h1>
<p id="rfc.section.2.p.1">This section discusses the requirements for discovery, negotiation and synchronization capabilities. The primary user of the protocol is an autonomic service agent (ASA), so the requirements are mainly expressed as the features needed by an ASA.  A single physical device might contain several ASAs, and a single ASA might manage several technical objectives. </p>
<p id="rfc.section.2.p.2">Note that requirements for ASAs themselves, such as the processing of Intent <a href="#RFC7575">[RFC7575]</a> or interfaces for coordination between ASAs are out of scope for the present document.</p>
<h1 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> Requirements for Discovery</h1>
<p id="rfc.section.2.1.p.1">1. ASAs may be designed to manage anything, as required in <a href="#synchreq">Section 2.2</a>. A basic requirement is therefore that the protocol can represent and discover any kind of technical objective among arbitrary subsets of participating nodes.</p>
<p id="rfc.section.2.1.p.2">In an autonomic network we must assume that when a device starts up it has no information about any peer devices, the network structure, or what specific role it must play. The ASA(s) inside the device are in the same situation. In some cases, when a new application session starts up within a device, the device or ASA may again lack information about relevant peers. It might be necessary to set up resources on multiple other devices, coordinated and matched to each other so that there is no wasted resource. Security settings might also need updating to allow for the new device or user.  The relevant peers may be different for different technical objectives. Therefore discovery needs to be repeated as often as necessary to find peers capable of acting as counterparts for each objective that a discovery initiator needs to handle.  From this background we derive the next three requirements:</p>
<p id="rfc.section.2.1.p.3">2. When an ASA first starts up, it has no knowledge of the specific network to which it is attached.  Therefore the discovery process must be able to support any network scenario, assuming only that the device concerned is bootstrapped from factory condition.  </p>
<p id="rfc.section.2.1.p.4">3. When an ASA starts up, it must require no information about any peers in order to discover them.</p>
<p id="rfc.section.2.1.p.5">4. If an ASA supports multiple technical objectives, relevant peers may be different for different discovery objectives, so discovery needs to be repeated to find counterparts for each objective. Thus, there must be a mechanism by which an ASA can separately discover peer ASAs for each of the technical objectives that it needs to manage, whenever necessary.</p>
<p id="rfc.section.2.1.p.6">5. Following discovery, an ASA will normally perform negotiation or synchronization for the corresponding objectives. The design should allow for this by associating discovery, negotiation and synchronization objectives. It may provide an optional mechanism to combine discovery and negotiation/synchronization in a single call.</p>
<p id="rfc.section.2.1.p.7">6. Some objectives may only be significant on the local link, but others may be significant across the routed network and require off-link operations. Thus, the relevant peers might be immediate neighbors on the same layer 2 link, or they might be more distant and only accessible via layer 3. The mechanism must therefore provide both on-link and off-link discovery of ASAs supporting specific technical objectives.</p>
<p id="rfc.section.2.1.p.8">7. The discovery process should be flexible enough to allow for special cases, such as the following: </p>

<ul>
  <li>In some networks, as mentioned above, there will be some hierarchical structure, at least for certain synchronization or negotiation objectives, but this is unknown in advance. The discovery protocol must therefore operate regardless of hierarchical structure, which is an attribute of individual technical objectives and not of the autonomic network as a whole.  This is part of the more general requirement to discover off-link peers.</li>
  <li>During initialisation, a device must be able to establish mutual trust with the rest of the network and join an authentication mechanism. Although this will inevitably start with a discovery action, it is a special case precisely because trust is not yet established. This topic is the subject of <a href="#I-D.pritikin-anima-bootstrapping-keyinfra">[I-D.pritikin-anima-bootstrapping-keyinfra]</a>.  We require that once trust has been established for a device, all ASAs within the device inherit the device's credentials and are also trusted.</li>
  <li>Depending on the type of network involved, discovery of other central functions might be needed, such as the Network Operations Center (NOC) <a href="#I-D.eckert-anima-stable-connectivity">[I-D.eckert-anima-stable-connectivity]</a>.  The protocol must be capable of supporting such discovery during initialisation, as well as discovery during ongoing operation.</li>
</ul>
<p id="rfc.section.2.1.p.9">8. The discovery process must not generate excessive (multicast) traffic and must take account of sleeping nodes in the case of a resource-constrained network <a href="#RFC7228">[RFC7228]</a>. </p>
<h1 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a> <a href="#synchreq" id="synchreq">Requirements for Synchronization and Negotiation Capability</a></h1>
<p id="rfc.section.2.2.p.1">As background, consider the example of routing protocols, the closest approximation to autonomic networking already in widespread use. Routing protocols use a largely autonomic model based on distributed devices that communicate repeatedly with each other. The focus is reachability, so current routing protocols mainly consider simple link status, i.e., up or down, and an underlying assumption is that all nodes need a consistent view of the network topology in order for the routing algorithm to converge. Thus, routing is mainly based on information synchronization between peers, rather than on bi-directional negotiation. Other information, such as latency, congestion, capacity, and particularly unused capacity, would be helpful to get better path selection and utilization rate, but is not normally used in distributed routing algorithms. Additionally, autonomic networks need to be able to manage many more dimensions, such as security settings, power saving, load balancing, etc.  Status information and traffic metrics need to be shared between nodes for dynamic adjustment of resources and for monitoring purposes.  While this might be achieved by existing protocols when they are available, the new protocol needs to be able to support parameter exchange, including mutual synchronization, even when no negotiation as such is required. In general, these parameters do not apply to all participating nodes, but only to a subset. </p>
<p id="rfc.section.2.2.p.2">9. A basic requirement for the protocol is therefore the ability to represent, discover, synchronize and negotiate almost any kind of network parameter among arbitrary subsets of participating nodes.</p>
<p id="rfc.section.2.2.p.3">10. Negotiation is a request/response process that must be guaranteed to terminate (with success or failure) and if necessary it must contain tie-breaking rules for each technical objective that requires them. While these must be defined specifically for each use case, the protocol should have some general mechanisms in support of loop and deadlock prevention, such as hop count limits or timeouts.</p>
<p id="rfc.section.2.2.p.4">11. Synchronization might concern small groups of nodes or very large groups.  Different solutions might be needed at different scales. </p>
<p id="rfc.section.2.2.p.5">12. To avoid "reinventing the wheel", the protocol should be able to carry the message formats used by existing configuration protocols (such as NETCONF/YANG) in cases where that is convenient.</p>
<p id="rfc.section.2.2.p.6">13. Human intervention in complex situations is costly and error-prone.  Therefore, synchronization or negotiation of parameters without human intervention is desirable whenever the coordination of multiple devices can improve overall network performance. It therefore follows that the protocol, as part of the Autonomic Networking Infrastructure, must be capable of running in any device that would otherwise need human intervention.</p>
<p id="rfc.section.2.2.p.7">14. Human intervention in large networks is often replaced by use of a top-down network management system (NMS). It therefore follows that the protocol, as part of the Autonomic Networking Infrastructure, must be capable of running in any device that would otherwise be managed by an NMS, and that it can co-exist with an NMS, and with protocols such as SNMP and NETCONF.</p>
<p id="rfc.section.2.2.p.8">15. Some features are expected to be implemented by individual ASAs, but the protocol must be general enough to allow them: </p>

<ul>
  <li>Dependencies and conflicts: In order to decide a configuration on a given device, the device may need information from neighbors. This can be established through the negotiation procedure, or through synchronization if that is sufficient. However, a given item in a neighbor may depend on other information from its own neighbors, which may need another negotiation or synchronization procedure to obtain or decide.  Therefore, there are potential dependencies and conflicts among negotiation or synchronization procedures. Resolving dependencies and conflicts is a matter for the individual ASAs involved.  To allow this, there need to be clear boundaries and convergence mechanisms for negotiations. Also some mechanisms are needed to avoid loop dependencies. In such a case, the protocol's role is limited to signaling between ASAs. </li>
  <li>Recovery from faults and identification of faulty devices should be as automatic as possible. The protocol's role is limited to the ability to handle discovery, synchronization and negotiation at any time, in case an ASA detects an anomaly such as a negotiation counterpart failing.</li>
  <li>Since the goal is to minimize human intervention, it is necessary that the network can in effect "think ahead" before changing its parameters. In other words there must be a possibility of forecasting the effect of a change by a "dry run" mechanism before actually installing the change. This will be an application of the protocol rather than a feature of the protocol itself. </li>
  <li>Management logging, monitoring, alerts and tools for intervention are required.  However, these can only be features of individual ASAs.  Another document <a href="#I-D.eckert-anima-stable-connectivity">[I-D.eckert-anima-stable-connectivity]</a> discusses how such agents may be linked into conventional OAM systems via an Autonomic Control Plane <a href="#I-D.behringer-anima-autonomic-control-plane">[I-D.behringer-anima-autonomic-control-plane]</a>. </li>
</ul>
<p id="rfc.section.2.2.p.9">16. The protocol will be able to deal with a wide variety of technical objectives, covering any type of network parameter.  Therefore the protocol will need either an explicit information model describing its messages, or at least a flexible and easily extensible message format. One design consideration is whether to adopt an existing information model or to design a new one. </p>
<h1 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3.</a> Specific Technical Requirements</h1>
<p id="rfc.section.2.3.p.1">17. It should be convenient for ASA designers to define new technical objectives and for programmers to express them, without excessive impact on run-time efficiency and footprint. The classes of device in which the protocol might run is discussed in <a href="#I-D.behringer-anima-reference-model">[I-D.behringer-anima-reference-model]</a>.</p>
<p id="rfc.section.2.3.p.2">18. The protocol should be easily extensible in case the initially defined discovery, synchronization and negotiation mechanisms prove to be insufficient. </p>
<p id="rfc.section.2.3.p.3">19. To be a generic platform, the protocol payload format should be independent of the transport protocol or IP version.  In particular, it should be able to run over IPv6 or IPv4.  However, some functions, such as multicasting or broadcasting on a link, might need to be IP version dependent. In case of doubt, IPv6 should be preferred.</p>
<p id="rfc.section.2.3.p.4">20. The protocol must be able to access off-link counterparts via routable addresses, i.e., must not be restricted to link-local operation.</p>
<p id="rfc.section.2.3.p.5">21. It must also be possible for an external discovery mechanism to be used, if appropriate for a given technical objective. In other words, GRASP discovery must not be a prerequisite for GRASP negotiation or synchronization; the prerequisite is discovering a peer's locator by any method. </p>
<p id="rfc.section.2.3.p.6">22. ASAs and the signaling protocol engine need to run asynchronously when wait states occur.</p>
<p id="rfc.section.2.3.p.7">23. Intent: There must be provision for general Intent rules to be applied by all devices in the network (e.g., security rules, prefix length, resource sharing rules). However, Intent distribution might not use the signaling protocol itself, but its design should not exclude such use. </p>
<p id="rfc.section.2.3.p.8">24. Management monitoring, alerts and intervention: Devices should be able to report to a monitoring system. Some events must be able to generate operator alerts and some provision for emergency intervention must be possible (e.g.  to freeze synchronization or negotiation in a mis-behaving device). These features might not use the signaling protocol itself, but its design should not exclude such use.</p>
<p id="rfc.section.2.3.p.9">25. The protocol needs to be fully secured against forged messages and man-in-the middle attacks, and secured as much as reasonably possible against denial of service attacks. It needs to be capable of encryption in order to resist unwanted monitoring, although this capability may not be required in all deployments. However, it is not required that the protocol itself provides these security features; it may depend on an existing secure environment. </p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#Overview" id="Overview">GRASP Protocol Overview</a></h1>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#terms" id="terms">Terminology</a></h1>
<p id="rfc.section.3.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a> when they appear in ALL CAPS. When these words are not in ALL CAPS (such as "should" or "Should"), they have their usual English meanings, and are not to be interpreted as <a href="#RFC2119">[RFC2119]</a> key words.</p>
<p id="rfc.section.3.1.p.2">This document uses terminology defined in <a href="#RFC7575">[RFC7575]</a>.</p>
<p id="rfc.section.3.1.p.3">The following additional terms are used throughout this document: </p>

<ul>
  <li>Autonomic Device: identical to Autonomic Node.</li>
  <li>Discovery: a process by which an ASA discovers peers according to a specific discovery objective. The discovery results may be different according to the different discovery objectives.  The discovered peers may later be used as negotiation counterparts or as sources of synchronization data. </li>
  <li>Negotiation: a process by which two (or more) ASAs interact iteratively to agree on parameter settings that best satisfy the objectives of one or more ASAs.</li>
  <li>State Synchronization: a process by which two (or more) ASAs interact to agree on the current state of parameter values stored in each ASA. This is a special case of negotiation in which information is sent but the ASAs do not request their peers to change parameter settings. All other definitions apply to both negotiation and synchronization. </li>
  <li>Technical Objective (usually abbreviated as Objective): A technical objective is a configurable parameter or set of parameters of some kind, which occurs in three contexts: Discovery, Negotiation and Synchronization. In the protocol, an objective is represented by an identifier (actually a GRASP option number) and if relevant a value.  Normally, a given objective will occur during discovery and negotiation, or during discovery and synchronization, but not in all three contexts.  <ul><li>One ASA may support multiple independent objectives.</li><li>The parameter described by a given objective is naturally based on a specific service or function or action. It may in principle be anything that can be set to a specific logical, numerical or string value, or a more complex data structure, by a network node.  That node is generally expected to contain an ASA which may itself manage other nodes.</li><li>Discovery Objective: if a node needs to synchronize or negotiate a specific objective but does not know a peer that supports this objective, it starts a discovery process. The objective is called a Discovery Objective during this process.</li><li>Synchronization Objective: an objective whose specific technical content needs to be synchronized among two or more ASAs. </li><li>Negotiation Objective: an objective whose specific technical content needs to be decided in coordination with another ASA. </li></ul></li>
  <li>Discovery Initiator: an ASA that spontaneously starts discovery by sending a discovery message referring to a specific discovery objective.</li>
  <li>Discovery Responder: a peer ASA which responds to the discovery objective initiated by the discovery initiator.</li>
  <li>Synchronization Initiator: an ASA that spontaneously starts synchronization by sending a request message referring to a specific synchronization objective.</li>
  <li>Synchronization Responder: a peer ASA which responds with the value of a synchronization objective.</li>
  <li>Negotiation Initiator: an ASA that spontaneously starts negotiation by sending a request message referring to a specific negotiation objective.</li>
  <li>Negotiation Counterpart: a peer with which the Negotiation Initiator negotiates a specific negotiation objective.</li>
</ul>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#highlevel" id="highlevel">High-Level Design Choices</a></h1>
<p id="rfc.section.3.2.p.1">This section describes a behavior model and some considerations for designing a generic signaling protocol initially supporting discovery, synchronization and negotiation, which can act as a platform for different technical objectives.</p>
<p id="rfc.section.3.2.p.2">NOTE: An earlier version of this protocol used type-length-value formats and was prototyped by Huawei and the Beijing University of Posts and Telecommunications.</p>
<p/>

<ul>
  <li>A generic platform<br/><br/> The protocol is designed as a generic platform, which is independent from the synchronization or negotiation contents. It takes care of the general intercommunication between counterparts. The technical contents will vary according to the various technical objectives and the different pairs of counterparts.<br/><br/></li>
  <li>The protocol is expected to form part of an Autonomic Networking Infrastructure <a href="#I-D.behringer-anima-reference-model">[I-D.behringer-anima-reference-model]</a>. It will provide services to ASAs via a suitable application programming interface, which will reflect the protocol elements but will not necessarily be in one-to-one correspondence to them. It is expected that the protocol engine and each ASA will run as independent asynchronous processes.<br/><br/></li>
  <li>Security infrastructure and trust relationship<br/><br/> Because this negotiation protocol may directly cause changes to device configurations and bring significant impacts to a running network, this protocol is assumed to run within an existing secure environment with strong authentication.  <br/><br/> On the other hand, a limited negotiation model might be deployed based on a limited trust relationship. For example, between two administrative domains, ASAs might also exchange limited information and negotiate some particular configurations based on a limited conventional or contractual trust relationship.<br/><br/></li>
  <li>Discovery, synchronization and negotiation are designed together.<br/><br/> The discovery method and the synchronization and negotiation methods are designed in the same way and can be combined when this is useful. These processes can also be performed independently when appropriate.  <ul><li>GRASP discovery is always available for efficient discovery of GRASP peers and allows a rapid mode of operation described in <a href="#discmech">Section 3.3.3</a>.  For some objectives, especially those concerned with application layer services, another discovery mechanism such as the future DNS Service Discovery <a href="#RFC7558">[RFC7558]</a> or Service Location Protocol <a href="#RFC2608">[RFC2608]</a> MAY be used. The choice is left to the designers of individual ASAs.  </li></ul><br/><br/></li>
  <li>A uniform pattern for technical contents<br/><br/> The synchronization and negotiation contents are defined according to a uniform pattern. They could be carried either in simple binary format or in payloads described by a flexible language. The basic protocol design uses the Concise Binary Object Representation (CBOR) <a href="#RFC7049">[RFC7049]</a>.  The format is extensible for unknown future requirements. <br/><br/></li>
  <li>A flexible model for synchronization<br/><br/> GRASP supports bilateral synchronization, which could be used to perform synchronization among a small number of nodes.  It also supports an unsolicited flooding mode when large groups of nodes, possibly including all autonomic nodes, need data for the same technical objective.  <ul><li>There may be some network parameters for which a more traditional flooding mechanism such as DNCP <a href="#I-D.ietf-homenet-dncp">[I-D.ietf-homenet-dncp]</a> is considered more appropriate. GRASP can coexist with DNCP.  </li></ul><br/><br/></li>
  <li>A simple initiator/responder model for negotiation<br/><br/> Multi-party negotiations are too complicated to be modeled and there might be too many dependencies among the parties to converge efficiently. A simple initiator/responder model is more feasible and can complete multi-party negotiations by indirect steps.  <br/><br/></li>
  <li>Organizing of synchronization or negotiation content<br/><br/> Naturally, the technical content will be organized according to the relevant function or service. The content from different functions or services is kept independent from each other. They are not combined into a single option or single session because these contents may be negotiated or synchronized with different counterparts or may be different in response time.<br/><br/></li>
  <li>Self-aware network device<br/><br/>Every autonomic device will be pre-loaded with various functions and ASAs and will be aware of its own capabilities, typically decided by the hardware, firmware or pre-installed software. Its exact role may depend on Intent and on the surrounding network behaviors, which may include forwarding behaviors, aggregation properties, topology location, bandwidth, tunnel or translation properties, etc. The surrounding topology will depend on the network planning. Following an initial discovery phase, the device properties and those of its neighbors are the foundation of the synchronization or negotiation behavior of a specific device. A device has no pre-configuration for the particular network in which it is installed.<br/><br/></li>
  <li>Requests and responses in negotiation procedures<br/><br/> The initiator can negotiate with its relevant negotiation counterpart ASAs, which may be different according to the specific negotiation objective. It can request relevant information from the negotiation counterpart so that it can decide its local configuration to give the most coordinated performance. It can request the negotiation counterpart to make a matching configuration in order to set up a successful communication with it. It can request certain simulation or forecast results by sending some dry run conditions.  <br/><br/>Beyond the traditional yes/no answer, the responder can reply with a suggested alternative if its answer is 'no'. This would start a bi-directional negotiation ending in a compromise between the two ASAs.<br/><br/></li>
  <li>Convergence of negotiation procedures<br/><br/> To enable convergence, when a responder makes a suggestion of a changed condition in a negative reply, it should be as close as possible to the original request or previous suggestion. The suggested value of the third or later negotiation steps should be chosen between the suggested values from the last two negotiation steps. In any case there must be a mechanism to guarantee convergence (or failure) in a small number of steps, such as a timeout or maximum number of iterations.  <br/><br/> <ul><li>End of negotiation<br/><br/> A limited number of rounds, for example three, or a timeout, is needed on each ASA for each negotiation objective. It may be an implementation choice, a pre-configurable parameter, or network Intent.  These choices might vary between different types of ASA.  Therefore, the definition of each negotiation objective MUST clearly specify this, so that the negotiation can always be terminated properly.  <br/><br/></li><li>Failed negotiation<br/><br/>There must be a well-defined procedure for concluding that a negotiation cannot succeed, and if so deciding what happens next (deadlock resolution, tie-breaking, or revert to best-effort service). Again, this MUST be specified for individual negotiation objectives, as an implementation choice, a pre-configurable parameter, or network Intent.</li></ul></li>
</ul>
<h1 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> GRASP Protocol Basic Properties and Mechanisms</h1>
<h1 id="rfc.section.3.3.1"><a href="#rfc.section.3.3.1">3.3.1.</a> <a href="#reqsec" id="reqsec">Required External Security Mechanism</a></h1>
<p id="rfc.section.3.3.1.p.1">The protocol SHOULD run within a secure Autonomic Control Plane (ACP) <a href="#I-D.behringer-anima-autonomic-control-plane">[I-D.behringer-anima-autonomic-control-plane]</a>. The procedure for establishing the ACP MUST provide an indication to GRASP that the ACP has been established. </p>
<p id="rfc.section.3.3.1.p.2">If there is no ACP, the protocol MUST use another form of strong authentication and SHOULD use a form of strong encryption. TLS <a href="#RFC5246">[RFC5246]</a> or DTLS <a href="#RFC6347">[RFC6347]</a> are RECOMMENDED for this purpose, based on a local Public Key Infrastructure (PKI) <a href="#RFC5280">[RFC5280]</a> managed within the autonomic network itself. </p>
<p id="rfc.section.3.3.1.p.3">Link-local multicast is used for discovery messages. It is expected that the ACP will handle these and distribute them securely to all on-link ACP nodes only.  However, in the absence of an ACP they cannot be secured.  Responses to discovery messages MUST be secured.</p>
<p id="rfc.section.3.3.1.p.4">During initialisation, before a node has joined the applicable trust infrastructure, e.g., <a href="#I-D.pritikin-anima-bootstrapping-keyinfra">[I-D.pritikin-anima-bootstrapping-keyinfra]</a>, it might be impossible to secure certain messages.  Such messages MUST be limited to the strictly necessary minimum.  A full analysis of the secure bootstrap process is out of scope for the present document. </p>
<h1 id="rfc.section.3.3.2"><a href="#rfc.section.3.3.2">3.3.2.</a> Transport Layer Usage</h1>
<p id="rfc.section.3.3.2.p.1">The protocol is capable of running over UDP or TCP, except for link-local multicast discovery messages, which can only run over UDP and MUST NOT be fragmented, and therefore cannot exceed the link MTU size. </p>
<p id="rfc.section.3.3.2.p.2">When running within a secure ACP, UDP SHOULD be used for messages not exceeding the minimum IPv6 path MTU, and TCP MUST be used for longer messages. In other words, IPv6 fragmentation is avoided. If a node receives a UDP message but the reply is too long, it MUST open a TCP connection to the peer for the reply.</p>
<p id="rfc.section.3.3.2.p.3">When running without an ACP, TLS MUST be supported and used by default, except for multicast discovery messages. DTLS MAY be supported as an alternative but the details are out of scope for this document. </p>
<p id="rfc.section.3.3.2.p.4">For all transport protocols, the GRASP protocol listens to the GRASP Listen Port (<a href="#Constants">Section 3.5</a>).</p>
<h1 id="rfc.section.3.3.3"><a href="#rfc.section.3.3.3">3.3.3.</a> <a href="#discmech" id="discmech">Discovery Mechanism and Procedures</a></h1>
<p/>

<ul>
  <li>Separated discovery and negotiation mechanisms<ul class="empty"><li>Although discovery and negotiation or synchronization are defined together in the GRASP, they are separated mechanisms. The discovery process could run independently from the negotiation or synchronization process. Upon receiving a discovery (<a href="#DiscoveryMessage">Section 3.7.2</a>) or request (<a href="#RequestMessage">Section 3.7.4</a>) message, the recipient ASA should return a message in which it either indicates itself as a discovery responder or diverts the initiator towards another more suitable ASA.</li><li>The discovery action will normally be followed by a negotiation or synchronization action. The discovery results could be utilized by the negotiation protocol to decide which ASA the initiator will negotiate with.</li></ul></li>
  <li>Discovery Procedures<ul class="empty"><li>Discovery starts as an on-link operation. The Divert option can tell the discovery initiator to contact an off-link ASA for that discovery objective. Every Discovery message is sent by a discovery initiator via UDP to the ALL_GRASP_NEIGHBOR multicast address (<a href="#Constants">Section 3.5</a>). Every network device that supports the GRASP always listens to a well-known UDP port to capture the discovery messages.</li><li>If an ASA in the neighbor device supports the requested discovery objective, it MAY respond with a Response message (<a href="#ResponseMessage">Section 3.7.3</a>) with locator option(s). Otherwise, if the neighbor has cached information about an ASA that supports the requested discovery objective (usually because it discovered the same objective before), it SHOULD respond with a Response message with a Divert option pointing to the appropriate Discovery Responder.</li><li>If no discovery response is received within a reasonable timeout (default GRASP_DEF_TIMEOUT milliseconds, <a href="#Constants">Section 3.5</a>), the Discovery message MAY be repeated, with a newly generated Session ID (<a href="#SessionID">Section 3.6</a>). An exponential backoff SHOULD be used for subsequent repetitions, in order to mitigate possible denial of service attacks.</li><li>After a GRASP device successfully discovers a Discovery Responder supporting a specific objective, it MUST cache this information. This cache record MAY be used for future negotiation or synchronization, and SHOULD be passed on when appropriate as a Divert option to another Discovery Initiator. The cache lifetime is an implementation choice that MAY be modified by network Intent.</li><li>If multiple Discovery Responders are found for the same objective, they SHOULD all be cached, unless this creates a resource shortage. The method of choosing between multiple responders is an implementation choice.</li><li>A GRASP device with multiple link-layer interfaces (typically a router) MUST support discovery on all interfaces. If it receives a Discovery message on a given interface for a specific objective that it does not support and for which it has not previously discovered a Discovery Responder, it MUST relay the query by re-issuing the same Discovery message on its other interfaces.  Before this, it MUST decrement the loop count within the objective, and discard the Discovery message if the result is zero.  Also, it MUST limit the total rate at which it relays discovery messages to a reasonable value, in order to mitigate possible denial of service attacks.  It MUST cache the Session ID value of each relayed discovery message and, to prevent loops, MUST NOT relay a Discovery message which carries such a cached Session ID.  These precautions avoid discovery loops and mitigate potential overload.</li><li>This relayed discovery mechanism, with caching of the results, should be sufficient to support most network bootstrapping scenarios.</li></ul></li>
  <li>A complete discovery process will start with multicast on the local link; a neighbor might divert it to an off-link destination, which could be a default higher-level gateway in a hierarchical network.  Then discovery would continue with a unicast to that gateway; if that gateway is still not the right counterpart, it should divert to another gateway, which is in principle closer to the right counterpart. Finally the right counterpart responds to start the negotiation or synchronization process.  </li>
  <li>Rapid Mode (Discovery/Negotiation binding)<ul class="empty"><li>A Discovery message MAY include one or more Negotiation Objective option(s). This allows a rapid mode of negotiation described in <a href="#negproc">Section 3.3.4</a>. A similar mechanism is defined for synchronization in <a href="#synchproc">Section 3.3.5</a>.</li></ul></li>
</ul>
<h1 id="rfc.section.3.3.4"><a href="#rfc.section.3.3.4">3.3.4.</a> <a href="#negproc" id="negproc">Negotiation Procedures</a></h1>
<p id="rfc.section.3.3.4.p.1">A negotiation initiator sends a negotiation request to a counterpart ASA, including a specific negotiation objective.  It may request the negotiation counterpart to make a specific configuration. Alternatively, it may request a certain simulation or forecast result by sending a dry run configuration.  The details, including the distinction between dry run and an actual configuration change, will be defined separately for each type of negotiation objective.</p>
<p id="rfc.section.3.3.4.p.2">If no reply message of any kind is received within a reasonable timeout (default GRASP_DEF_TIMEOUT milliseconds, <a href="#Constants">Section 3.5</a>), the negotiation request MAY be repeated, with a newly generated Session ID (<a href="#SessionID">Section 3.6</a>). An exponential backoff SHOULD be used for subsequent repetitions.</p>
<p id="rfc.section.3.3.4.p.3">If the counterpart can immediately apply the requested configuration, it will give an immediate positive (accept) answer.  This will end the negotiation phase immediately. Otherwise, it will negotiate. It will reply with a proposed alternative configuration that it can apply (typically, a configuration that uses fewer resources than requested by the negotiation initiator). This will start a bi-directional negotiation to reach a compromise between the two ASAs.</p>
<p id="rfc.section.3.3.4.p.4">The negotiation procedure is ended when one of the negotiation peers sends a Negotiation Ending message, which contains an accept or decline option and does not need a response from the negotiation peer. Negotiation may also end in failure (equivalent to a decline) if a timeout is exceeded or a loop count is exceeded. </p>
<p id="rfc.section.3.3.4.p.5">A negotiation procedure concerns one objective and one counterpart. Both the initiator and the counterpart may take part in simultaneous negotiations with various other ASAs, or in simultaneous negotiations about different objectives. Thus, GRASP is expected to be used in a multi-threaded mode. Certain negotiation objectives may have restrictions on multi-threading, for example to avoid over-allocating resources.</p>
<p id="rfc.section.3.3.4.p.6">Rapid Mode (Discovery/Negotiation linkage)</p>

<ul class="empty">
  <li>A Discovery message MAY include a Negotiation Objective option. In this case the Discovery message also acts as a Request message to indicate to the Discovery Responder that it could directly reply to the Discovery Initiator with a Negotiation message for rapid processing, if it could act as the corresponding negotiation counterpart. However, the indication is only advisory not prescriptive. </li>
  <li>This rapid mode could reduce the interactions between nodes so that a higher efficiency could be achieved. This rapid negotiation function SHOULD be configured off by default and MAY be configured on or off by Intent.</li>
</ul>
<h1 id="rfc.section.3.3.5"><a href="#rfc.section.3.3.5">3.3.5.</a> <a href="#synchproc" id="synchproc">Synchronization Procedure</a></h1>
<p id="rfc.section.3.3.5.p.1">A synchronization initiator sends a synchronization request to a counterpart, including a specific synchronization objective.  The counterpart responds with a Response message containing the current value of the requested synchronization objective. No further messages are needed. </p>
<p id="rfc.section.3.3.5.p.2">If no reply message of any kind is received within a reasonable timeout (default GRASP_DEF_TIMEOUT milliseconds, <a href="#Constants">Section 3.5</a>), the negotiation request MAY be repeated, with a newly generated Session ID (<a href="#SessionID">Section 3.6</a>). An exponential backoff SHOULD be used for subsequent repetitions.</p>
<p id="rfc.section.3.3.5.p.3">In the case just described, the message exchange is unicast and concerns only one synchronization objective. For large groups of nodes requiring the same data, synchronization flooding is available. For this, a synchronization responder MAY send an unsolicited Response message containing one or more Synchronization Objective option(s), if and only if the specification of those objectives permits it. This is sent as a multicast message to the ALL_GRASP_NEIGHBOR multicast address (<a href="#Constants">Section 3.5</a>).  To ensure that flooding does not result in a loop, the originator of the Response message MUST set the loop count in the objective to a suitable value (the default is GRASP_DEF_LOOPCT).  In this case a suitable mechanism is needed to avoid excessive multicast traffic. This mechanism MUST be defined as part of the specification of the synchronization objective(s) concerned. It might be a simple rate limit or a more complex mechanism such as the Trickle algorithm <a href="#RFC6206">[RFC6206]</a>.</p>
<p id="rfc.section.3.3.5.p.4">A GRASP device with multiple link-layer interfaces (typically a router) MUST support synchronization flooding on all interfaces. If it receives a multicast unsolicited Response message on a given interface, it MUST relay it by re-issuing the same Response message on its other interfaces.  Before this, it MUST decrement the loop count within the objective, and discard the Response message if the result is zero.  Also, it MUST limit the total rate at which it relays Response messages to a reasonable value, in order to mitigate possible denial of service attacks.  It MUST cache the Session ID value of each relayed Response message and, to prevent loops, MUST NOT relay a Response message which carries such a cached Session ID. These precautions avoid synchronization loops and mitigate potential overload.</p>
<p id="rfc.section.3.3.5.p.5">Note that this mechanism is unreliable in the case of sleeping nodes. Sleeping nodes that require an objective subject to synchronization flooding SHOULD periodically initiate normal synchronization for that objective. </p>
<p id="rfc.section.3.3.5.p.6">Rapid Mode (Discovery/Synchronization linkage)</p>

<ul class="empty">
  <li>A Discovery message MAY include one or more Synchronization Objective option(s). In this case the Discovery message also acts as a Request message to indicate to the Discovery Responder that it could directly reply to the Discovery Initiator with a Response message with synchronization data for rapid processing, if the discovery target supports the corresponding synchronization objective(s). However, the indication is only advisory not prescriptive.</li>
  <li>This rapid mode could reduce the interactions between nodes so that a higher efficiency could be achieved. This rapid synchronization function SHOULD be configured off by default and MAY be configured on or off by Intent.</li>
</ul>
<h1 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a> High Level Deployment Model</h1>
<p id="rfc.section.3.4.p.1">It is expected that a GRASP implementation will reside in an autonomic node that also contains both the appropriate security environment (preferably the ACP) and one or more Autonomic Service Agents (ASAs). In the minimal case of a single-purpose device, these three components might be fully integrated. A more common model is expected to be a multi-purpose device capable of containing several ASAs. In this case it is expected that the ACP, GRASP and the ASAs will be implemented as separate processes, which are probably multi-threaded to support asynchronous operation. In this case well defined Application Programming Interfaces (APIs) will be needed between the ACP and GRASP, and between GRASP and the ASAs. For further details of possible deployment models, see <a href="#I-D.behringer-anima-reference-model">[I-D.behringer-anima-reference-model]</a>.  </p>
<h1 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5.</a> <a href="#Constants" id="Constants">GRASP Constants</a></h1>
<p/>

<ul>
  <li>ALL_GRASP_NEIGHBOR<br/><br/>A link-local scope multicast address used by a GRASP-enabled device to discover GRASP-enabled neighbor (i.e., on-link) devices . All devices that support GRASP are members of this multicast group.<ul><li>IPv6 multicast address: TBD1</li><li>IPv4 multicast address: TBD2</li></ul></li>
  <li>GRASP Listen Port (TBD3)<br/><br/>A UDP and TCP port that every GRASP-enabled network device always listens to.</li>
  <li>GRASP_DEF_TIMEOUT (60000 milliseconds)<br/><br/>The default timeout used to determine that a discovery etc. has failed to complete.</li>
  <li>GRASP_DEF_LOOPCT (6)<br/><br/>The default loop count used to determine that a negotiation has failed to complete, and to avoid looping messages.</li>
</ul>
<h1 id="rfc.section.3.6"><a href="#rfc.section.3.6">3.6.</a> <a href="#SessionID" id="SessionID">Session Identifier (Session ID)</a></h1>
<p id="rfc.section.3.6.p.1">This is an up to 24-bit opaque value used to distinguish multiple sessions between the same two devices. A new Session ID MUST be generated for every new Discovery or Request message, and for every unsolicited Response message.  All follow-up messages in the same discovery, synchronization or negotiation procedure, which is initiated by the request message, MUST carry the same Session ID.</p>
<p id="rfc.section.3.6.p.2">The Session ID SHOULD have a very low collision rate locally. It MUST be generated by a pseudo-random algorithm using a locally generated seed which is unlikely to be used by any other device in the same network <a href="#RFC4086">[RFC4086]</a>.</p>
<h1 id="rfc.section.3.7"><a href="#rfc.section.3.7">3.7.</a> <a href="#GRASPMessages" id="GRASPMessages">GRASP Messages</a></h1>
<p id="rfc.section.3.7.p.1">This section defines the GRASP message format and message types.  Message types not listed here are reserved for future use. </p>
<h1 id="rfc.section.3.7.1"><a href="#rfc.section.3.7.1">3.7.1.</a> GRASP Message Format</h1>
<p id="rfc.section.3.7.1.p.1">GRASP messages share an identical header format and a variable format area for options. GRASP message headers and options are transmitted in Concise Binary Object Representation (CBOR) <a href="#RFC7049">[RFC7049]</a>. In this specification, they are described using CBOR data definition language (CDDL) <a href="#I-D.greevenbosch-appsawg-cbor-cddl">[I-D.greevenbosch-appsawg-cbor-cddl]</a>.  Fragmentary CDDL is used to describe each item in this section. A complete and normative CDDL specification of GRASP is given in <a href="#cddl">Section 6</a>.  </p>
<p id="rfc.section.3.7.1.p.2">Every GRASP message carries a Session ID (<a href="#SessionID">Section 3.6</a>).  Options are then presented serially in the options field.</p>
<p id="rfc.section.3.7.1.p.3">In fragmentary CDDL, every GRASP message follows the pattern:</p>
<pre>
  message /= [MESSAGE_TYPE, session-id, *option]
          
  MESSAGE_TYPE = ; a defined constant
  session-id =   0..16777215
  option /=      ; one of the options defined below
  </pre>
<p/>
<h1 id="rfc.section.3.7.2"><a href="#rfc.section.3.7.2">3.7.2.</a> <a href="#DiscoveryMessage" id="DiscoveryMessage">Discovery Message</a></h1>
<p id="rfc.section.3.7.2.p.1">In fragmentary CDDL, a Discovery message follows the pattern:</p>
<pre>
  discovery-message = [M_DISCOVERY, session-id, objective]
     
  M_DISCOVERY =  ; a defined constant
  session-id =   0..16777215
  objective /=   ; defined below
  </pre>
<p/>
<p id="rfc.section.3.7.2.p.3">A discovery initiator sends a Discovery message to initiate a discovery process.  </p>
<p id="rfc.section.3.7.2.p.4">The discovery initiator sends the Discovery messages to the link-local ALL_GRASP_NEIGHBOR multicast address for discovery, and stores the discovery results (including responding discovery objectives and corresponding unicast addresses or FQDNs).  </p>
<p id="rfc.section.3.7.2.p.5">A Discovery message MUST include exactly one of the following: </p>

<ul>
  <li>a discovery objective option (<a href="#ObjOption">Section 3.9.1</a>).  Its loop count must be set to a suitable value to prevent discovery loops (default value is GRASP_DEF_LOOPCT).  </li>
  <li>a negotiation objective option (<a href="#ObjOption">Section 3.9.1</a>) to indicate to the discovery target that it MAY directly reply to the discovery initiatior with a Negotiation message for rapid processing, if it could act as the corresponding negotiation counterpart.  The sender of such a Discovery message MUST initialize a negotiation timer and loop count in the same way as a Request message (<a href="#RequestMessage">Section 3.7.4</a>).  </li>
  <li>one or more synchronization objective options (<a href="#ObjOption">Section 3.9.1</a>) to indicate to the discovery target that it MAY directly reply to the discovery initiator with a Response message for rapid processing, if it could act as the corresponding synchronization counterpart.</li>
</ul>
<h1 id="rfc.section.3.7.3"><a href="#rfc.section.3.7.3">3.7.3.</a> <a href="#ResponseMessage" id="ResponseMessage">Response Message</a></h1>
<p id="rfc.section.3.7.3.p.1">In fragmentary CDDL, a Response message follows the pattern:</p>
<pre>
  response-message = [M_RESPONSE, session-id, 
                      +locator-option / divert-option / objective]
          
  M_RESPONSE =       ; a defined constant
  session-id =       0..16777215
  locator-option /=  ; defined below
  divert-option =    ; defined below
  objective /=       ; defined below
  </pre>
<p/>
<p id="rfc.section.3.7.3.p.3">A node which receives a Discovery message sends a Response message to respond to a discovery. It MUST contain the same Session ID as the Discovery message.  It MAY include a copy of the discovery objective from the Discovery message.  </p>
<p id="rfc.section.3.7.3.p.4">If the responding node supports the discovery objective of the discovery, it MUST include at least one kind of locator option (<a href="#LocatorOption">Section 3.8.7</a>) to indicate its own location. A combination of multiple kinds of locator options (e.g. IP address option + FQDN option) is also valid.  </p>
<p id="rfc.section.3.7.3.p.5">If the responding node itself does not support the discovery objective, but it knows the locator of the discovery objective, then it SHOULD respond to the discovery message with a divert option (<a href="#DivertOption">Section 3.8.2</a>) embedding a locator option or a combination of multiple kinds of locator options which indicate the locator(s) of the discovery objective.  </p>
<p id="rfc.section.3.7.3.p.6">A node which receives a synchronization request sends a Response message with the synchronization data, in the form of GRASP Option(s) for the specific synchronization objective(s).</p>
<h1 id="rfc.section.3.7.4"><a href="#rfc.section.3.7.4">3.7.4.</a> <a href="#RequestMessage" id="RequestMessage">Request Message</a></h1>
<p id="rfc.section.3.7.4.p.1">In fragmentary CDDL, a Request message follows the pattern:</p>
<pre>
  discovery-message = [M_REQUEST, session-id, objective]
          
  M_REQUEST =    ; a defined constant
  session-id =   0..16777215
  objective /=   ; defined below
  </pre>
<p/>
<p id="rfc.section.3.7.4.p.3">A negotiation or synchronization requesting node sends the Request message to the unicast address (directly stored or resolved from the FQDN) of the negotiation or synchronization counterpart (selected from the discovery results).</p>
<p id="rfc.section.3.7.4.p.4">A request message MUST include the relevant objective option, with the requested value in the case of negotiation. </p>
<p id="rfc.section.3.7.4.p.5">When an initiator sends a Request message, it MUST initialize a negotiation timer for the new negotiation thread with the value GRASP_DEF_TIMEOUT milliseconds. Unless this timeout is modified by a Confirm-waiting message (<a href="#ConfirmWaitingMessage">Section 3.7.7</a>), the initiator will consider that the negotiation has failed when the timer expires. </p>
<p id="rfc.section.3.7.4.p.6">When an initiator sends a Request message, it MUST initialize the loop count of the objective option with a value defined in the specification of the option or, if no such value is specified, with GRASP_DEF_LOOPCT. </p>
<h1 id="rfc.section.3.7.5"><a href="#rfc.section.3.7.5">3.7.5.</a> <a href="#NegotiationMessage" id="NegotiationMessage">Negotiation Message</a></h1>
<p id="rfc.section.3.7.5.p.1">In fragmentary CDDL, a Negotiation message follows the pattern:</p>
<pre>
  discovery-message = [M_NEGOTIATE, session-id, objective]
          
  M_NEGOTIATE =  ; a defined constant
  session-id =   0..16777215
  objective /=   ; defined below
  </pre>
<p/>
<p id="rfc.section.3.7.5.p.3">A negotiation counterpart sends a Negotiation message in response to a Request message, a Negotiation message, or a Discovery message in Rapid Mode. A negotiation process MAY include multiple steps.</p>
<p id="rfc.section.3.7.5.p.4">The Negotiation message MUST include the relevant Negotiation Objective option, with its value updated according to progress in the negotiation. The sender MUST decrement the loop count by 1. If the loop count becomes zero both parties will consider that the negotiation has failed.</p>
<h1 id="rfc.section.3.7.6"><a href="#rfc.section.3.7.6">3.7.6.</a> <a href="#NegotiationEndingMessage" id="NegotiationEndingMessage">Negotiation-ending Message</a></h1>
<p id="rfc.section.3.7.6.p.1">In fragmentary CDDL, a Negotiation-ending message follows the pattern:</p>
<pre>
  end-message = [M_END, session-id, accept-option / decline-option]
          
  M_END =          ; a defined constant
  session-id =     0..16777215
  accept-option =  ; defined below
  decline-option   ; defined below
  </pre>
<p/>
<p id="rfc.section.3.7.6.p.3">A negotiation counterpart sends an Negotiation-ending message to close the negotiation. It MUST contain one, but only one of accept/decline option, defined in <a href="#AcceptOption">Section 3.8.3</a> and <a href="#DeclineOption">Section 3.8.4</a>.  It could be sent either by the requesting node or the responding node.</p>
<h1 id="rfc.section.3.7.7"><a href="#rfc.section.3.7.7">3.7.7.</a> <a href="#ConfirmWaitingMessage" id="ConfirmWaitingMessage">Confirm-waiting Message</a></h1>
<p id="rfc.section.3.7.7.p.1">In fragmentary CDDL, a Confirm-waiting message follows the pattern:</p>
<pre>
  wait-message = [M_WAIT, session-id, waiting-time-option]
          
  M_WAIT =              ; a defined constant
  session-id =          0..16777215
  waiting-time-option = ; defined below
  </pre>
<p/>
<p id="rfc.section.3.7.7.p.3">A responding node sends a Confirm-waiting message to indicate the requesting node to wait for a further negotiation response. It might be that the local process needs more time or that the negotiation depends on another triggered negotiation. This message MUST NOT include any other options than the Waiting Time Option (<a href="#WaitingTimeOption">Section 3.8.5</a>).</p>
<h1 id="rfc.section.3.8"><a href="#rfc.section.3.8">3.8.</a> <a href="#GRASPOptions" id="GRASPOptions">GRASP General Options</a></h1>
<p id="rfc.section.3.8.p.1">This section defines the GRASP general options for the negotiation and synchronization protocol signaling. Additional option types are reserved for GRASP general options defined in the future.</p>
<h1 id="rfc.section.3.8.1"><a href="#rfc.section.3.8.1">3.8.1.</a> Format of GRASP Options</h1>
<p id="rfc.section.3.8.1.p.1">GRASP options are CBOR objects that MUST start with an unsigned integer identifying the specific option type carried in this option. Apart from that the only format requirement is each option MUST be a well-formed CBOR object. In general a CBOR array format is RECOMMENDED to limit overhead.</p>
<p id="rfc.section.3.8.1.p.2">GRASP options are usually scoped by using encapsulation. However, this is not a requirement</p>
<h1 id="rfc.section.3.8.2"><a href="#rfc.section.3.8.2">3.8.2.</a> <a href="#DivertOption" id="DivertOption">Divert Option</a></h1>
<p id="rfc.section.3.8.2.p.1">The Divert option is used to redirect a GRASP request to another node, which may be more appropriate for the intended negotiation or synchronization. It may redirect to an entity that is known as a specific negotiation or synchronization counterpart (on-link or off-link) or a default gateway. The divert option MUST only be encapsulated in Response messages.  If found elsewhere, it SHOULD be silently ignored.</p>
<p id="rfc.section.3.8.2.p.2">In fragmentary CDDL, the Divert option follows the pattern:</p>
<pre>
  divert-option = [O_DIVERT, +locator-option]
          
  O_DIVERT =       ; a defined constant
  locator-option = ; defined below
  </pre>
<p/>
<p id="rfc.section.3.8.2.p.4">The embedded Locator Option(s) (<a href="#LocatorOption">Section 3.8.7</a>) point to diverted destination target(s) in response to a Discovery message. </p>
<p id="rfc.section.3.8.2.p.5">Note: Currently the need for this option is disputed. It might be removed or modified.</p>
<h1 id="rfc.section.3.8.3"><a href="#rfc.section.3.8.3">3.8.3.</a> <a href="#AcceptOption" id="AcceptOption">Accept Option</a></h1>
<p id="rfc.section.3.8.3.p.1">The accept option is used to indicate to the negotiation counterpart that the proposed negotiation content is accepted.</p>
<p id="rfc.section.3.8.3.p.2">The accept option MUST only be encapsulated in Negotiation-ending messages. If found elsewhere, it SHOULD be silently ignored.</p>
<p id="rfc.section.3.8.3.p.3">In fragmentary CDDL, the Accept option follows the pattern:</p>
<pre>
  accept-option = [O_ACCEPT]
          
  O_ACCEPT =       ; a defined constant
  </pre>
<p/>
<h1 id="rfc.section.3.8.4"><a href="#rfc.section.3.8.4">3.8.4.</a> <a href="#DeclineOption" id="DeclineOption">Decline Option</a></h1>
<p id="rfc.section.3.8.4.p.1">The decline option is used to indicate to the negotiation counterpart the proposed negotiation content is declined and end the negotiation process.</p>
<p id="rfc.section.3.8.4.p.2">The decline option MUST only be encapsulated in Negotiation-ending messages. If found elsewhere, it SHOULD be silently ignored.</p>
<p id="rfc.section.3.8.4.p.3">In fragmentary CDDL, the Decline option follows the pattern:</p>
<pre>
  decline-option = [O_DECLINE]
          
  O_DECLINE =       ; a defined constant
  </pre>
<p/>
<p id="rfc.section.3.8.4.p.5">Notes: there are scenarios where a negotiation counterpart wants to decline the proposed negotiation content and continue the negotiation process. For these scenarios, the negotiation counterpart SHOULD use a Negotiate message, with either an objective option that contains a data field set to indicate a meaningless initial value, or a specific objective option that provides further conditions for convergence.</p>
<h1 id="rfc.section.3.8.5"><a href="#rfc.section.3.8.5">3.8.5.</a> <a href="#WaitingTimeOption" id="WaitingTimeOption">Waiting Time Option</a></h1>
<p id="rfc.section.3.8.5.p.1">The waiting time option is used to indicate that the negotiation counterpart needs to wait for a further negotiation response, since the processing might need more time than usual or it might depend on another triggered negotiation.</p>
<p id="rfc.section.3.8.5.p.2">The waiting time option MUST only be encapsulated in Confirm-waiting messages. If found elsewhere, it SHOULD be silently ignored. When received, its value overwrites the negotiation timer (<a href="#RequestMessage">Section 3.7.4</a>).</p>
<p id="rfc.section.3.8.5.p.3">The counterpart SHOULD send a Negotiation, Negotiation-Ending or another Confirm-waiting message before the negotiation timer expires. If not, the initiator MUST abandon or restart the negotiation procedure, to avoid an indefinite wait.</p>
<p id="rfc.section.3.8.5.p.4">In fragmentary CDDL, the Waiting-time option follows the pattern:</p>
<pre>
  waiting-time-option = [O_WAITING, option-waiting-time]
          
  O_WAITING =           ; a defined constant
  option-waiting-time = 0..4294967295 ; in milliseconds
  </pre>
<p/>
<h1 id="rfc.section.3.8.6"><a href="#rfc.section.3.8.6">3.8.6.</a> <a href="#IDOption" id="IDOption">Device Identity Option</a></h1>
<p id="rfc.section.3.8.6.p.1">The Device Identity option carries the identities of the sender and of the domain(s) that it belongs to. </p>
<p id="rfc.section.3.8.6.p.2">In fragmentary CDDL, the Device Identity option follows the pattern:</p>
<pre>
  option-device-id = [O_DEVICE_ID, bytes]
          
  O_DEVICE_ID =   ; a defined constant
  </pre>
<p/>
<p id="rfc.section.3.8.6.p.4">The option contains a variable-length field containing the device identity and one or more domain identities. The format is not yet defined.  </p>
<p id="rfc.section.3.8.6.p.5">Note: Currently this option is a placeholder. It might be removed or modified.</p>
<h1 id="rfc.section.3.8.7"><a href="#rfc.section.3.8.7">3.8.7.</a> <a href="#LocatorOption" id="LocatorOption">Locator Options</a></h1>
<p id="rfc.section.3.8.7.p.1">These locator options are used to present reachability information for an ASA, a device or an interface. They are Locator IPv4 Address Option, Locator IPv6 Address Option, Locator FQDN (Fully Qualified Domain Name) Option and Uniform Resource Locator Option.</p>
<p id="rfc.section.3.8.7.p.2">Note: It is assumed that all locators are in scope throughout the GRASP domain. GRASP is not intended to work across disjoint addressing or naming realms. </p>
<h1 id="rfc.section.3.8.7.1"><a href="#rfc.section.3.8.7.1">3.8.7.1.</a> Locator IPv4 address option</h1>
<p id="rfc.section.3.8.7.1.p.1">In fragmentary CDDL, the IPv4 address option follows the pattern:</p>
<pre>
  ipv4-locator-option = bytes .size 4
  </pre>
<p/>
<p id="rfc.section.3.8.7.1.p.3">The content of this option is a binary IPv4 address.</p>
<p id="rfc.section.3.8.7.1.p.4">Note: If an operator has internal network address translation for IPv4, this option MUST NOT be used within the Divert option.</p>
<h1 id="rfc.section.3.8.7.2"><a href="#rfc.section.3.8.7.2">3.8.7.2.</a> Locator IPv6 address option</h1>
<p id="rfc.section.3.8.7.2.p.1">In fragmentary CDDL, the IPv6 address option follows the pattern:</p>
<pre>
  ipv6-locator-option = bytes .size 16
  </pre>
<p/>
<p id="rfc.section.3.8.7.2.p.3">The content of this option is a binary IPv6 address.</p>
<p id="rfc.section.3.8.7.2.p.4">Note: A link-local IPv6 address MUST NOT be used when this option is used within the Divert option.</p>
<h1 id="rfc.section.3.8.7.3"><a href="#rfc.section.3.8.7.3">3.8.7.3.</a> Locator FQDN option</h1>
<p id="rfc.section.3.8.7.3.p.1">In fragmentary CDDL, the FQDN option follows the pattern:</p>
<pre>
  fqdn-locator-option = [O_FQDN_LOCATOR, text]
          
  O_FQDN_LOCATOR =   ; a defined constant
  </pre>
<p/>
<p id="rfc.section.3.8.7.3.p.3">The content of this option is the Fully Qualified Domain Name of the target.  </p>
<p id="rfc.section.3.8.7.3.p.4">Note: Any FQDN which might not be valid throughout the network in question, such as a Multicast DNS name <a href="#RFC6762">[RFC6762]</a>, MUST NOT be used when this option is used within the Divert option.</p>
<h1 id="rfc.section.3.8.7.4"><a href="#rfc.section.3.8.7.4">3.8.7.4.</a> Locator URL option</h1>
<p id="rfc.section.3.8.7.4.p.1">In fragmentary CDDL, the URL option follows the pattern:</p>
<pre>
  url-locator-option = [O_URL_LOCATOR, text]
          
  O_URL_LOCATOR =   ; a defined constant
  </pre>
<p/>
<p id="rfc.section.3.8.7.4.p.3">The content of this option is the Uniform Resource Locator of the target <a href="#RFC3986">[RFC3986]</a>.  </p>
<p id="rfc.section.3.8.7.4.p.4">Note: Any URL which might not be valid throughout the network in question, such as one based on a Multicast DNS name <a href="#RFC6762">[RFC6762]</a>, MUST NOT be used when this option is used within the Divert option.</p>
<h1 id="rfc.section.3.9"><a href="#rfc.section.3.9">3.9.</a> Objective Options</h1>
<h1 id="rfc.section.3.9.1"><a href="#rfc.section.3.9.1">3.9.1.</a> <a href="#ObjOption" id="ObjOption">Format of Objective Options</a></h1>
<p id="rfc.section.3.9.1.p.1">An objective option is used to identify objectives for the purposes of discovery, negotiation or synchronization.  All objectives must follow one of two common formats as follows, described in fragmentary CDDL:</p>
<pre>
  generic-obj = [objective-name, objective-flags, loop-count, ?any]
  vendor-obj = [{"PEN":pen}, objective-name, objective-flags, 
                loop-count, ?any]
           
  objective-name = tstr
  pen = 0..4294967295
  loop-count = 0..255
  objective-flags \=     ; defined below
  </pre>
<p/>
<p id="rfc.section.3.9.1.p.3">All objectives are identified by a unique name which is a UTF-8 string.  The names of generic objectives MUST be registered with IANA.</p>
<p id="rfc.section.3.9.1.p.4">The name "PEN" and the value following it MUST be prepended to indicate vendor-defined objectives. The associated value uniquely identifies the enterprise that defines the option, in the form of a registered 32 bit Private Enterprise Number (PEN) <a href="#I-D.liang-iana-pen">[I-D.liang-iana-pen]</a>. There is no default value for this field.  Note that it is not used during discovery. It MUST be verified during negotiation or synchronization.</p>
<p id="rfc.section.3.9.1.p.5">The 'loop-count' field is used for terminating negotiation as described in <a href="#NegotiationMessage">Section 3.7.5</a>. It is also used for terminating discovery as described in <a href="#discmech">Section 3.3.3</a>, and for terminating flooding as described in FLOODING.  </p>
<p id="rfc.section.3.9.1.p.6">The 'any' field is to express the actual value of a negotiation or synchronization objective. Its format is defined in the specification of the objective and may be a single value or a data structure of any kind. It is optional because it is optional in a Discovery or Response message.</p>
<h1 id="rfc.section.3.9.2"><a href="#rfc.section.3.9.2">3.9.2.</a> Objective flags</h1>
<p id="rfc.section.3.9.2.p.1">An objective may be relevant for discovery, negotiation or synchronization. This is expressed in the objective by logical flags:</p>
<pre>
  objective-flags = uint .bits objective-flag
  objective-flag = &amp;(
  D: 0 ; valid for discovery only
  N: 1 ; valid for discovery and negotiation
  S: 2 ; valid for discovery and synchronization
  )
  </pre>
<p/>
<h1 id="rfc.section.3.9.3"><a href="#rfc.section.3.9.3">3.9.3.</a> <a href="#ConsOption" id="ConsOption">General Considerations for Objective Options</a></h1>
<p id="rfc.section.3.9.3.p.1">As mentioned above, generic Objective Options MUST be assigned a unique name.  As long as vendor-defined Objective Options start with a valid PEN, this document does not restrict their choice of name, but the vendor SHOULD publish the names in use. </p>
<p id="rfc.section.3.9.3.p.2">All Objective Options MUST respect the CBOR patterns defined above as "generic-obj" or "vendor-obj" and MUST replace the "any" field with a valid CBOR data definition for the relevant use case and application. </p>
<p id="rfc.section.3.9.3.p.3">An Objective Option that contains no additional fields beyond its "loop-count" can only be a discovery objective and MUST only be used in Discovery and Response messages.</p>
<p id="rfc.section.3.9.3.p.4">The Negotiation Objective Options contain negotiation objectives, which vary according to different functions/services. They MUST be carried by Discovery, Request or Negotiation Messages only. The negotiation initiator MUST set the initial "loop-count" to a value specified in the specification of the objective or, if no such value is specified, to GRASP_DEF_LOOPCT.</p>
<p id="rfc.section.3.9.3.p.5">For most scenarios, there should be initial values in the negotiation requests. Consequently, the Negotiation Objective options MUST always be completely presented in a Request message, or in a Discovery message in rapid mode. If there is no initial value, the bits in the value field SHOULD all be set to indicate a meaningless value, unless this is inappropriate for the specific negotiation objective.</p>
<p id="rfc.section.3.9.3.p.6">Synchronization Objective Options are similar, but MUST be carried by Discovery, Request or Response messages only. They include value fields only in Response messages. </p>
<h1 id="rfc.section.3.9.4"><a href="#rfc.section.3.9.4">3.9.4.</a> Organizing of Objective Options</h1>
<p id="rfc.section.3.9.4.p.1">Generic objective options MUST be specified in documents available to the public and MUST be designed to use either the negotiation or the synchronization mechanism described above.  </p>
<p id="rfc.section.3.9.4.p.2">As noted earlier, one negotiation objective is handled by each GRASP negotiation thread. Therefore, a negotiation objective, which is based on a specific function or action, SHOULD be organized as a single GRASP option. It is NOT RECOMMENDED to organize multiple negotiation objectives into a single option, nor to split a single function or action into multiple negotiation objectives. </p>
<p id="rfc.section.3.9.4.p.3">A synchronization objective SHOULD also be organized as a single GRASP option.</p>
<p id="rfc.section.3.9.4.p.4">Some objectives will support more than one operational mode.  An example is a negotiation objective with both a "dry run" mode (where the negotiation is to find out whether the other end can in fact make the requested change without problems) and a "live" mode. Such modes will be defined in the specification of such an objective. These objectives SHOULD include flags indicating the applicable mode(s).</p>
<p id="rfc.section.3.9.4.p.5">An objective may have multiple parameters. Parameters can be categorized into two classes: the obligatory ones presented as fixed fields; and the optional ones presented in CBOR sub-options or some other form of data structure embedded in CBOR. The format might be inherited from an existing management or configuration protocol, the objective option acting as a carrier for that format.  The data structure might be defined in a formal language, but that is a matter for the specifications of individual objectives.  There are many candidates, according to the context, such as ABNF, RBNF, XML Schema, possibly YANG, etc. The GRASP protocol itself is agnostic on these questions. </p>
<p id="rfc.section.3.9.4.p.6">It is NOT RECOMMENDED to split parameters in a single objective into multiple options, unless they have different response periods. An exception scenario may also be described by split objectives.</p>
<p id="rfc.section.3.9.4.p.7">All objectives MUST support GRASP discovery. However, as mentioned in <a href="#highlevel">Section 3.2</a>, it is acceptable for an ASA to use an alternative method of discovery. </p>
<p id="rfc.section.3.9.4.p.8">Normally, a GRASP objective will refer to specific technical parameters as explained in <a href="#terms">Section 3.1</a>. However, it is acceptable to define an abstract objective for the purpose of managing or coordinating ASAs.  It is also acceptable to define a special-purpose objective for purposes such as trust bootstrapping or formation of the ACP.</p>
<h1 id="rfc.section.3.9.5"><a href="#rfc.section.3.9.5">3.9.5.</a> Experimental and Example Objective Options</h1>
<p id="rfc.section.3.9.5.p.1">The names "EX0" through "EX9" have been reserved for experimental options.  Multiple names have been assigned because a single experiment may use multiple options simultaneously. These experimental options are highly likely to have different meanings when used for different experiments. Therefore, they SHOULD NOT be used without an explicit human decision and SHOULD NOT be used in unmanaged networks such as home networks.</p>
<p id="rfc.section.3.9.5.p.2">These names are also RECOMMENDED for use in documentation examples.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> Open Issues</h1>
<p id="rfc.section.4.p.1">There are various unresolved design questions that are worthy of more work in the near future, as listed below (statically numbered in historical order for reference purposes, with the resolved issues retained for reference): </p>

<ul>
  <li>1. UDP vs TCP: For now, this specification suggests UDP and TCP as message transport mechanisms. This is not clarified yet. UDP is good for short conversations, is necessary for multicast discovery, and generally fits the discovery and divert scenarios well. However, it will cause problems with large messages. TCP is good for stable and long sessions, with a little bit of time consumption during the session establishment stage. If messages exceed a reasonable MTU, a TCP mode will be required in any case.  This question may be affected by the security discussion.  <br/><br/> RESOLVED by specifying UDP for short message and TCP for longer one.  <br/><br/></li>
  <li>2. DTLS or TLS vs built-in security mechanism. For now, this specification has chosen a PKI based built-in security mechanism based on asymmetric cryptography. However, (D)TLS might be chosen as security solution to avoid duplication of effort. It also allows essentially similar security for short messages over UDP and longer ones over TCP. The implementation trade-offs are different.  The current approach requires expensive asymmetric cryptographic calculations for every message. (D)TLS has startup overheads but cheaper crypto per message.  DTLS is less mature than TLS.  <br/><br/> RESOLVED by specifying external security (ACP or (D)TLS).  <br/><br/> </li>
  <li>The following open issues apply only if the current security model is retained: <ul><li>2.1. For replay protection, GRASP currently requires every participant to have an NTP-synchronized clock. Is this OK for low-end devices, and how does it work during device bootstrapping? We could take the Timestamp out of signature option, to become an independent and OPTIONAL (or RECOMMENDED) option.</li><li>2.2. The Signature Option states that this option could be any place in a message. Wouldn't it be better to specify a position (such as the end)? That would be much simpler to implement. </li></ul><p>RESOLVED by changing security model.</p></li>
  <li>3. DoS Attack Protection needs work.  <br/><br/> RESOLVED by adding text.<br/><br/></li>
  <li>4. Should we consider preferring a text-based approach to discovery (after the initial discovery needed for bootstrapping)? This could be a complementary mechanism for multicast based discovery, especially for a very large autonomic network. Centralized registration could be automatically deployed incrementally. At the very first stage, the repository could be empty; then it could be filled in by the objectives discovered by different devices (for example using Dynamic DNS Update). The more records are stored in the repository, the less the multicast-based discovery is needed. However, if we adopt such a mechanism, there would be challenges: stateful solution, and security.  <br/><br/> RESOLVED for now by adding optional use of DNS-SD by ASAs.<br/><br/> </li>
  <li>5. Need to expand description of the minimum requirements for the specification of an individual discovery, synchronization or negotiation objective.  <br/><br/> RESOLVED for now by extra wording.</li>
  <li>6. Use case and protocol walkthrough. A description of how a node starts up, performs discovery, and conducts negotiation and synchronisation for a sample use case would help readers to understand the applicability of this specification.  Maybe it should be an artificial use case or maybe a simple real one, based on a conceptual API. However, the authors have not yet decided whether to have a separate document or have it in the protocol document.  <br/><br/> RESOLVED: recommend a separate document.</li>
  <li>7. Cross-check against other ANIMA WG documents for consistency and gaps.</li>
  <li>8. Consideration of ADNCP proposal.  <br/><br/> RESOLVED by adding optional use of DNCP for flooding-type synchronization.  <br/><br/></li>
  <li>9. Clarify how a GDNP instance knows whether it is running inside the ACP. (Sheng) <br/><br/> RESOLVED by improved text.<br/><br/></li>
  <li>10. Clarify how a non-ACP GDNP instance initiates (D)TLS. (Sheng) <br/><br/> RESOLVED by improved text and declaring DTLS out of scope for this draft.  <br/><br/></li>
  <li>11. Clarify how UDP/TCP choice is made. (Sheng) [Like DNS? - Brian] <br/><br/> RESOLVED by improved text.<br/><br/></li>
  <li>12. Justify that IP address within ACP or (D)TLS environment is sufficient to prove AN identity; or explain how Device Identity Option is used. (Sheng) <br/><br/> RESOLVED for now: we assume that all ASAs in a device are trusted as soon as the device is trusted, so they share credentials. In that case the Device Identity Option is useless. This needs to be reviewed later.<br/><br/></li>
  <li>13. Emphasise that negotiation/synchronization are independent from discovery, although the rapid discovery mode includes the first step of a negotiation/synchronization.  (Sheng) <br/><br/> RESOLVED by improved text. <br/><br/></li>
  <li>14. Do we need an unsolicited flooding mechanism for discovery (for discovery results that everyone needs), to reduce scaling impact of flooding discovery messages? (Toerless) <br/><br/> RESOLVED: Yes, added to requirements and solution. <br/><br/></li>
  <li>15. Do we need flag bits in Objective Options to distinguish distinguish Synchronization and Negotiation "Request" or rapid mode "Discovery" messages? (Bing) <br/><br/> RESOLVED: yes, work on the API showed that these flags are essential. </li>
  <li>16. (Related to issue 14). Should we revive the "unsolicited Response" for flooding synchronisation data? This has to be done carefully due to the well-known issues with flooding, but it could be useful, e.g. for Intent distribution, where DNCP doesn't seem applicable.  <br/><br/> RESOLVED: Yes, see #14.  </li>
  <li>17. Ensure that the discovery mechanism is completely proof against loops and protected against duplicate responses.  <br/><br/> RESOLVED: Added loop count mechanism.  </li>
  <li>18. Discuss the handling of multiple valid discovery responses.</li>
  <li>19. Should we use a text-oriented format such as JSON/CBOR instead of native binary TLV format? <br/><br/> RESOLVED: Yes, changed to CBOR </li>
  <li>20. Is the Divert option needed? If a discovery response provides a valid IP address or FQDN, the recipient doesn't gain any extra knowledge from the Divert.  On the other hand, the presence of Divert informs the receiver that the target is off-link, which might be useful sometimes.</li>
  <li>21. Rename the protocol as GRASP (GeneRic Autonomic Signaling Protocol)? <br/><br/> RESOLVED: Yes, name changed.</li>
  <li>22. Does discovery mechanism scale robustly as needed? Need hop limit on relaying? <br/><br/> RESOLVED: Added hop limit.</li>
  <li>23. Need more details on TTL for caching discovery responses.  <br/><br/> RESOLVED: Done.</li>
  <li>24. Do we need "fast withdrawal" of discovery responses? </li>
  <li>25. Does GDNP discovery meet the needs of multi-hop DNS-SD? </li>
  <li>26. Add a URL type to the locator options (for security bootstrap) <br/><br/> RESOLVED: Done. </li>
  <li>27. Security of unsolicited Response multicasts (<a href="#synchproc">Section 3.3.5</a>).</li>
  <li>28. Does ACP support multicast?</li>
  <li>29. PEN is used to distinguish vendor options. Would it be better to use a domain name? Anything unique will do.</li>
  <li>30. Does response to discovery require randomized delays to mitigate amplification attacks? </li>
  <li>31. We have specified repeats for failed discovery etc. Is that sufficient to deal with sleeping nodes?</li>
</ul>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#security" id="security">Security Considerations</a></h1>
<p id="rfc.section.5.p.1">It is obvious that a successful attack on negotiation-enabled nodes would be extremely harmful, as such nodes might end up with a completely undesirable configuration that would also adversely affect their peers.  GRASP nodes and messages therefore require full protection. </p>
<p id="rfc.section.5.p.2">- Authentication</p>

<dl>
  <dt></dt>
  <dd style="margin-left: 8">A cryptographically authenticated identity for each device is needed in an autonomic network. It is not safe to assume that a large network is physically secured against interference or that all personnel are trustworthy. Each autonomic node MUST be capable of proving its identity and authenticating its messages. GRASP relies on a separate external certificate-based security mechanism to support authentication, data integrity protection, and anti-replay protection.</dd>
  <dt></dt>
  <dd style="margin-left: 8">Since GRASP is intended to be deployed in a single administrative domain operating its own trust anchor and CA, there is no need for a trusted public third party. In a network requiring "air gap" security, such a dependency would be unacceptable. </dd>
  <dt></dt>
  <dd style="margin-left: 8">If GRASP is used temporarily without an external security mechanism, for example during system bootstrap (<a href="#reqsec">Section 3.3.1</a>), the Session ID (<a href="#SessionID">Section 3.6</a>) will act as a nonce to provide limited protection against third parties injecting responses.  A full analysis of the secure bootstrap process is out of scope for the present document. </dd>
</dl>
<p id="rfc.section.5.p.3">- Privacy and confidentiality</p>

<dl>
  <dt></dt>
  <dd style="margin-left: 8">Generally speaking, no personal information is expected to be involved in the signaling protocol, so there should be no direct impact on personal privacy. Nevertheless, traffic flow paths, VPNs, etc. could be negotiated, which could be of interest for traffic analysis. Also, operators generally want to conceal details of their network topology and traffic density from outsiders. Therefore, since insider attacks cannot be excluded in a large network, the security mechanism for the protocol MUST provide message confidentiality.</dd>
</dl>
<p id="rfc.section.5.p.4">- DoS Attack Protection</p>

<dl>
  <dt></dt>
  <dd style="margin-left: 8">GRASP discovery partly relies on insecure link-local multicast. Since routers participating in GRASP sometimes relay discovery messages from one link to another, this could be a vector for denial of service attacks. Relevant mitigations are specified in <a href="#discmech">Section 3.3.3</a>. Additionally, it is of great importance that firewalls prevent any GRASP messages from entering the domain from an untrusted source. </dd>
</dl>
<p id="rfc.section.5.p.5">- Security during bootstrap and discovery</p>

<dl>
  <dt></dt>
  <dd style="margin-left: 8">A node cannot authenticate GRASP traffic from other nodes until it has identified the trust anchor and can validate certificates for other nodes. Also, until it has succesfully enrolled <a href="#I-D.pritikin-anima-bootstrapping-keyinfra">[I-D.pritikin-anima-bootstrapping-keyinfra]</a> it cannot assume that other nodes are able to authenticate its own traffic.  Therefore, GRASP discovery during the bootstrap phase for a new device will inevitably be insecure and GRASP synchronization and negotiation will be impossible until enrollment is complete.</dd>
</dl>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#cddl" id="cddl">CDDL Specification of GRASP</a></h1>
<pre>
&lt;CODE BEGINS&gt;

grasp-message = message

session-id = 0..16777215
; that is up to 24 bits

message /= discovery-message
discovery-message = [M_DISCOVERY, session-id, objective]

message /= response-message
response-message = [M_RESPONSE, session-id, +locator-option] 
                 / [M_RESPONSE, session-id, divert-option / objective] 
; split to satisfy CDDL tool

message /= request-message
request-message = [M_REQUEST, session-id, objective]

message /= negotiation-message
negotiation-message = [M_NEGOTIATE, session-id, objective]

message /= end-message
end-message = [M_END, session-id, (accept-option / decline-option)]

message /= wait-message
wait-message = [M_WAIT, session-id, waiting-time-option]

divert-option = [O_DIVERT, +locator-option]

accept-option = [O_ACCEPT]

decline-option = [O_DECLINE]

waiting-time-option = [O_WAITING, option-waiting-time]
option-waiting-time = 0..4294967295 ; in milliseconds

option-device-id = [O_DEVICE_ID, bytes]

locator-option /= ipv4-locator-option
ipv4-locator-option = bytes .size 4
; this is simpler than [O_IPv4_LOCATOR, bytes .size 4]

locator-option /= ipv6-locator-option
ipv6-locator-option = bytes .size 16

locator-option /= fqdn-locator-option
fqdn-locator-option = [O_FQDN_LOCATOR, text]

locator-option /= url-locator-option
url-locator-option = [O_URL_LOCATOR, text]

objective-flags = uint .bits objective-flag

objective-flag = &amp;(
D: 0
N: 1
S: 2
)

; D means valid for discovery only
; N means valid for discovery and negotiation
; S means valid for discovery and synchronization

objective /= generic-obj
generic-obj = [objective-name, objective-flags, loop-count, ?any]

objective /= vendor-obj
vendor-obj = [{"PEN":pen}, objective-name, objective-flags, 
              loop-count, ?any]

; A PEN is used to distinguish vendor-specific options.

pen = 0..4294967295
objective-name = tstr
loop-count = 0..255

; Constants

M_DISCOVERY = 1
M_RESPONSE = 2
M_REQUEST = 3
M_NEGOTIATE = 4
M_END = 5
M_WAIT = 6

O_DIVERT = 100
O_ACCEPT = 101
O_DECLINE = 102
O_WAITING = 103
O_DEVICE_ID = 104
O_FQDN_LOCATOR = 105
O_URL_LOCATOR = 106


&lt;CODE ENDS&gt;
    </pre>
<p/>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#iana" id="iana">IANA Considerations</a></h1>
<p><a href="#Constants">Section 3.5</a> defines the following link-local multicast addresses, which have been assigned by IANA for use by GRASP:</p>
<p/>

<dl>
  <dt>ALL_GRASP_NEIGHBOR multicast address</dt>
  <dd style="margin-left: 8">(IPv6): (TBD1).  Assigned in the IPv6 Link-Local Scope Multicast Addresses registry.</dd>
  <dt>ALL_GRASP_NEIGHBOR multicast address</dt>
  <dd style="margin-left: 8">(IPv4): (TBD2).  Assigned in the IPv4 Multicast Local Network Control Block.  <br/><br/> (Note in draft: alternatively, we could use 224.0.0.1, currently defined as All Systems on this Subnet.)</dd>
</dl>
<p><a href="#Constants">Section 3.5</a> defines the following UDP and TCP port, which has been assigned by IANA for use by GRASP:</p>
<p/>

<dl>
  <dt>GRASP Listen Port:</dt>
  <dd style="margin-left: 8">(TBD3)</dd>
</dl>
<p id="rfc.section.7.p.5">This document defines the General Discovery and Negotiation Protocol (GRASP). The IANA is requested to create a GRASP Parameter Registry.  The IANA is also requested to add two new registry tables to the newly-created GRASP Parameter Registry. The two tables are the GRASP Messages and Options Table and the GRASP Objective Names Table.</p>
<p id="rfc.section.7.p.6">GRASP Messages and Options Table. The values in this table are names paired with decimal integers. Future values MUST be assigned using the Standards Action policy defined by <a href="#RFC5226">[RFC5226]</a>. The following initial values are assigned by this document:</p>
<pre> M_DISCOVERY = 1
 M_RESPONSE = 2
 M_REQUEST = 3
 M_NEGOTIATE = 4
 M_END = 5
 M_WAIT = 6

 O_DIVERT = 100
 O_ACCEPT = 101
 O_DECLINE = 102
 O_WAITING = 103
 O_DEVICE_ID = 104
 O_FQDN_LOCATOR = 105
 O_URL_LOCATOR = 106
</pre>
<p/>
<p id="rfc.section.7.p.8">GRASP Objective Names Table. The values in this table are UTF-8 strings.  Future values MUST be assigned using the Specification Required policy defined by <a href="#RFC5226">[RFC5226]</a>.  The following initial values are assigned by this document:</p>
<pre> EX0
 EX1
 EX2
 EX3
 EX4
 EX5
 EX6
 EX7
 EX8
 EX9
 PEN
</pre>
<p/>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#ack" id="ack">Acknowledgements</a></h1>
<p id="rfc.section.8.p.1">A major contribution to the original version of this document was made by Sheng Jiang.</p>
<p id="rfc.section.8.p.2">Valuable comments were received from Michael Behringer, Jeferson Campos Nobre, Laurent Ciavaglia, Zongpeng Du, Yu Fu, Zhenbin Li, Dimitri Papadimitriou, Pierre Peloso, Reshad Rahman, Michael Richardson, Markus Stenberg, Rene Struik, Dacheng Zhang, and other participants in the NMRG research group and the ANIMA working group.</p>
<p id="rfc.section.8.p.3">This document was produced using the xml2rfc tool <a href="#RFC2629">[RFC2629]</a>.</p>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> <a href="#changes" id="changes">Change log [RFC Editor: Please remove]</a></h1>
<p id="rfc.section.9.p.1">draft-ietf-anima-grasp-01, 2015-09-25: <br/><br/> Updated requirements after list discussion.  <br/><br/> Changed from TLV to CBOR format - many detailed changes, added co-author.  <br/><br/> Tightened up loop count and timeouts for various cases.  <br/><br/> Various other clarifications.  </p>
<p id="rfc.section.9.p.2">draft-ietf-anima-grasp-00, 2015-08-14: <br/><br/> File name and protocol name changed following WG adoption.  <br/><br/> Added URL locator type.  </p>
<p id="rfc.section.9.p.3">draft-carpenter-anima-gdn-protocol-04, 2015-06-21: <br/><br/> Tuned wording around hierarchical structure.  <br/><br/> Changed "device" to "ASA" in many places.  <br/><br/> Reformulated requirements to be clear that the ASA is the main customer for signaling.  <br/><br/> Added requirement for flooding unsolicited synch, and added it to protocol spec.  Recognized DNCP as alternative for flooding synch data.  <br/><br/> Requirements clarified, expanded and rearranged following design team discussion.  <br/><br/> Clarified that GDNP discovery must not be a prerequisite for GDNP negotiation or synchronization (resolved issue 13).  <br/><br/> Specified flag bits for objective options (resolved issue 15).  <br/><br/> Clarified usage of ACP vs TLS/DTLS and TCP vs UDP (resolved issues 9,10,11).  <br/><br/> Updated DNCP description from latest DNCP draft.  <br/><br/> Editorial improvements.</p>
<p id="rfc.section.9.p.4">draft-carpenter-anima-gdn-protocol-03, 2015-04-20: <br/><br/> Removed intrinsic security, required external security <br/><br/> Format changes to allow DNCP co-existence <br/><br/> Recognized DNS-SD as alternative discovery method.  <br/><br/> Editorial improvements</p>
<p id="rfc.section.9.p.5">draft-carpenter-anima-gdn-protocol-02, 2015-02-19: <br/><br/> Tuned requirements to clarify scope, <br/><br/> Clarified relationship between types of objective, <br/><br/> Clarified that objectives may be simple values or complex data structures, <br/><br/> Improved description of objective options, <br/><br/> Added loop-avoidance mechanisms (loop count and default timeout, limitations on discovery relaying and on unsolicited responses), <br/><br/> Allow multiple discovery objectives in one response, <br/><br/> Provided for missing or multiple discovery responses, <br/><br/> Indicated how modes such as "dry run" should be supported, <br/><br/> Minor editorial and technical corrections and clarifications, <br/><br/> Reorganized future work list. </p>
<p id="rfc.section.9.p.6">draft-carpenter-anima-gdn-protocol-01, restructured the logical flow of the document, updated to describe synchronization completely, add unsolicited responses, numerous corrections and clarifications, expanded future work list, 2015-01-06. </p>
<p id="rfc.section.9.p.7">draft-carpenter-anima-gdn-protocol-00, combination of draft-jiang-config-negotiation-ps-03 and draft-jiang-config-negotiation-protocol-02, 2014-10-08.</p>
<h1 id="rfc.references"><a href="#rfc.references">10.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">10.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.greevenbosch-appsawg-cbor-cddl">[I-D.greevenbosch-appsawg-cbor-cddl]</b>
      </td>
      <td class="top"><a>Vigano, C.</a> and <a>H. Birkholz</a>, "<a href="http://tools.ietf.org/html/draft-greevenbosch-appsawg-cbor-cddl-06">CBOR data definition language: a notational convention to express CBOR data structures.</a>", Internet-Draft draft-greevenbosch-appsawg-cbor-cddl-06, July 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3986">[RFC3986]</b>
      </td>
      <td class="top"><a>Berners-Lee, T.</a>, <a>Fielding, R.</a> and <a>L. Masinter</a>, "<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4086">[RFC4086]</b>
      </td>
      <td class="top"><a>Eastlake 3rd, D.</a>, <a>Schiller, J.</a> and <a>S. Crocker</a>, "<a href="http://tools.ietf.org/html/rfc4086">Randomness Requirements for Security</a>", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5246">[RFC5246]</b>
      </td>
      <td class="top"><a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, DOI 10.17487/RFC5246, August 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5280">[RFC5280]</b>
      </td>
      <td class="top"><a>Cooper, D.</a>, <a>Santesson, S.</a>, <a>Farrell, S.</a>, <a>Boeyen, S.</a>, <a>Housley, R.</a> and <a>W. Polk</a>, "<a href="http://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 5280, DOI 10.17487/RFC5280, May 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6347">[RFC6347]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a> and <a>N. Modadugu</a>, "<a href="http://tools.ietf.org/html/rfc6347">Datagram Transport Layer Security Version 1.2</a>", RFC 6347, DOI 10.17487/RFC6347, January 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7049">[RFC7049]</b>
      </td>
      <td class="top"><a>Bormann, C.</a> and <a>P. Hoffman</a>, "<a href="http://tools.ietf.org/html/rfc7049">Concise Binary Object Representation (CBOR)</a>", RFC 7049, DOI 10.17487/RFC7049, October 2013.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">10.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.behringer-anima-autonomic-control-plane">[I-D.behringer-anima-autonomic-control-plane]</b>
      </td>
      <td class="top"><a>Behringer, M.</a>, <a>Bjarnason, S.</a>, <a>BL, B.</a> and <a>T. Eckert</a>, "<a href="http://tools.ietf.org/html/draft-behringer-anima-autonomic-control-plane-03">An Autonomic Control Plane</a>", Internet-Draft draft-behringer-anima-autonomic-control-plane-03, June 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.behringer-anima-reference-model">[I-D.behringer-anima-reference-model]</b>
      </td>
      <td class="top"><a>Behringer, M.</a>, <a>Carpenter, B.</a>, <a>Eckert, T.</a>, <a>Ciavaglia, L.</a>, <a>Liu, B.</a>, <a>Jeff, J.</a> and <a>J. Strassner</a>, "<a href="http://tools.ietf.org/html/draft-behringer-anima-reference-model-03">A Reference Model for Autonomic Networking</a>", Internet-Draft draft-behringer-anima-reference-model-03, June 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.chaparadza-intarea-igcp">[I-D.chaparadza-intarea-igcp]</b>
      </td>
      <td class="top"><a>Behringer, M.</a>, <a>Chaparadza, R.</a>, <a>Petre, R.</a>, <a>Li, X.</a> and <a>H. Mahkonen</a>, "<a href="http://tools.ietf.org/html/draft-chaparadza-intarea-igcp-00">IP based Generic Control Protocol (IGCP)</a>", Internet-Draft draft-chaparadza-intarea-igcp-00, July 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.eckert-anima-stable-connectivity">[I-D.eckert-anima-stable-connectivity]</b>
      </td>
      <td class="top"><a>Eckert, T.</a> and <a>M. Behringer</a>, "<a href="http://tools.ietf.org/html/draft-eckert-anima-stable-connectivity-01">Using Autonomic Control Plane for Stable Connectivity of Network OAM</a>", Internet-Draft draft-eckert-anima-stable-connectivity-01, March 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-homenet-dncp">[I-D.ietf-homenet-dncp]</b>
      </td>
      <td class="top"><a>Stenberg, M.</a> and <a>S. Barth</a>, "<a href="http://tools.ietf.org/html/draft-ietf-homenet-dncp-10">Distributed Node Consensus Protocol</a>", Internet-Draft draft-ietf-homenet-dncp-10, September 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-homenet-hncp">[I-D.ietf-homenet-hncp]</b>
      </td>
      <td class="top"><a>Stenberg, M.</a>, <a>Barth, S.</a> and <a>P. Pfister</a>, "<a href="http://tools.ietf.org/html/draft-ietf-homenet-hncp-09">Home Networking Control Protocol</a>", Internet-Draft draft-ietf-homenet-hncp-09, August 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-netconf-restconf">[I-D.ietf-netconf-restconf]</b>
      </td>
      <td class="top"><a>Bierman, A.</a>, <a>Bjorklund, M.</a> and <a>K. Watsen</a>, "<a href="http://tools.ietf.org/html/draft-ietf-netconf-restconf-07">RESTCONF Protocol</a>", Internet-Draft draft-ietf-netconf-restconf-07, July 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.liang-iana-pen">[I-D.liang-iana-pen]</b>
      </td>
      <td class="top"><a>Liang, P.</a>, <a>Melnikov, A.</a> and <a>D. Conrad</a>, "<a href="http://tools.ietf.org/html/draft-liang-iana-pen-06">Private Enterprise Number (PEN) practices and Internet Assigned Numbers Authority (IANA) registration considerations</a>", Internet-Draft draft-liang-iana-pen-06, July 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.pritikin-anima-bootstrapping-keyinfra">[I-D.pritikin-anima-bootstrapping-keyinfra]</b>
      </td>
      <td class="top"><a>Pritikin, M.</a>, <a>Richardson, M.</a>, <a>Behringer, M.</a> and <a>S. Bjarnason</a>, "<a href="http://tools.ietf.org/html/draft-pritikin-anima-bootstrapping-keyinfra-02">Bootstrapping Key Infrastructures</a>", Internet-Draft draft-pritikin-anima-bootstrapping-keyinfra-02, July 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.stenberg-anima-adncp">[I-D.stenberg-anima-adncp]</b>
      </td>
      <td class="top"><a>Stenberg, M.</a>, "<a href="http://tools.ietf.org/html/draft-stenberg-anima-adncp-00">Autonomic Distributed Node Consensus Protocol</a>", Internet-Draft draft-stenberg-anima-adncp-00, March 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2205">[RFC2205]</b>
      </td>
      <td class="top"><a>Braden, R.</a>, <a>Zhang, L.</a>, <a>Berson, S.</a>, <a>Herzog, S.</a> and <a>S. Jamin</a>, "<a href="http://tools.ietf.org/html/rfc2205">Resource ReSerVation Protocol (RSVP) -- Version 1 Functional Specification</a>", RFC 2205, DOI 10.17487/RFC2205, September 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2608">[RFC2608]</b>
      </td>
      <td class="top"><a>Guttman, E.</a>, <a>Perkins, C.</a>, <a>Veizades, J.</a> and <a>M. Day</a>, "<a href="http://tools.ietf.org/html/rfc2608">Service Location Protocol, Version 2</a>", RFC 2608, DOI 10.17487/RFC2608, June 1999.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2629">[RFC2629]</b>
      </td>
      <td class="top"><a>Rose, M.</a>, "<a href="http://tools.ietf.org/html/rfc2629">Writing I-Ds and RFCs using XML</a>", RFC 2629, DOI 10.17487/RFC2629, June 1999.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2865">[RFC2865]</b>
      </td>
      <td class="top"><a>Rigney, C.</a>, <a>Willens, S.</a>, <a>Rubens, A.</a> and <a>W. Simpson</a>, "<a href="http://tools.ietf.org/html/rfc2865">Remote Authentication Dial In User Service (RADIUS)</a>", RFC 2865, DOI 10.17487/RFC2865, June 2000.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3209">[RFC3209]</b>
      </td>
      <td class="top"><a>Awduche, D.</a>, <a>Berger, L.</a>, <a>Gan, D.</a>, <a>Li, T.</a>, <a>Srinivasan, V.</a> and <a>G. Swallow</a>, "<a href="http://tools.ietf.org/html/rfc3209">RSVP-TE: Extensions to RSVP for LSP Tunnels</a>", RFC 3209, DOI 10.17487/RFC3209, December 2001.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3315">[RFC3315]</b>
      </td>
      <td class="top"><a>Droms, R.</a>, <a>Bound, J.</a>, <a>Volz, B.</a>, <a>Lemon, T.</a>, <a>Perkins, C.</a> and <a>M. Carney</a>, "<a href="http://tools.ietf.org/html/rfc3315">Dynamic Host Configuration Protocol for IPv6 (DHCPv6)</a>", RFC 3315, DOI 10.17487/RFC3315, July 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3416">[RFC3416]</b>
      </td>
      <td class="top"><a>Presuhn, R.</a>, "<a href="http://tools.ietf.org/html/rfc3416">Version 2 of the Protocol Operations for the Simple Network Management Protocol (SNMP)</a>", STD 62, RFC 3416, DOI 10.17487/RFC3416, December 2002.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4861">[RFC4861]</b>
      </td>
      <td class="top"><a>Narten, T.</a>, <a>Nordmark, E.</a>, <a>Simpson, W.</a> and <a>H. Soliman</a>, "<a href="http://tools.ietf.org/html/rfc4861">Neighbor Discovery for IP version 6 (IPv6)</a>", RFC 4861, DOI 10.17487/RFC4861, September 2007.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5226">[RFC5226]</b>
      </td>
      <td class="top"><a>Narten, T.</a> and <a>H. Alvestrand</a>, "<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>", BCP 26, RFC 5226, DOI 10.17487/RFC5226, May 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5971">[RFC5971]</b>
      </td>
      <td class="top"><a>Schulzrinne, H.</a> and <a>R. Hancock</a>, "<a href="http://tools.ietf.org/html/rfc5971">GIST: General Internet Signalling Transport</a>", RFC 5971, DOI 10.17487/RFC5971, October 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6206">[RFC6206]</b>
      </td>
      <td class="top"><a>Levis, P.</a>, <a>Clausen, T.</a>, <a>Hui, J.</a>, <a>Gnawali, O.</a> and <a>J. Ko</a>, "<a href="http://tools.ietf.org/html/rfc6206">The Trickle Algorithm</a>", RFC 6206, DOI 10.17487/RFC6206, March 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6241">[RFC6241]</b>
      </td>
      <td class="top"><a>Enns, R.</a>, <a>Bjorklund, M.</a>, <a>Schoenwaelder, J.</a> and <a>A. Bierman</a>, "<a href="http://tools.ietf.org/html/rfc6241">Network Configuration Protocol (NETCONF)</a>", RFC 6241, DOI 10.17487/RFC6241, June 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6733">[RFC6733]</b>
      </td>
      <td class="top"><a>Fajardo, V.</a>, <a>Arkko, J.</a>, <a>Loughney, J.</a> and <a>G. Zorn</a>, "<a href="http://tools.ietf.org/html/rfc6733">Diameter Base Protocol</a>", RFC 6733, DOI 10.17487/RFC6733, October 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6762">[RFC6762]</b>
      </td>
      <td class="top"><a>Cheshire, S.</a> and <a>M. Krochmal</a>, "<a href="http://tools.ietf.org/html/rfc6762">Multicast DNS</a>", RFC 6762, DOI 10.17487/RFC6762, February 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6763">[RFC6763]</b>
      </td>
      <td class="top"><a>Cheshire, S.</a> and <a>M. Krochmal</a>, "<a href="http://tools.ietf.org/html/rfc6763">DNS-Based Service Discovery</a>", RFC 6763, DOI 10.17487/RFC6763, February 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6887">[RFC6887]</b>
      </td>
      <td class="top"><a>Wing, D.</a>, <a>Cheshire, S.</a>, <a>Boucadair, M.</a>, <a>Penno, R.</a> and <a>P. Selkirk</a>, "<a href="http://tools.ietf.org/html/rfc6887">Port Control Protocol (PCP)</a>", RFC 6887, DOI 10.17487/RFC6887, April 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7228">[RFC7228]</b>
      </td>
      <td class="top"><a>Bormann, C.</a>, <a>Ersue, M.</a> and <a>A. Keranen</a>, "<a href="http://tools.ietf.org/html/rfc7228">Terminology for Constrained-Node Networks</a>", RFC 7228, DOI 10.17487/RFC7228, May 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7558">[RFC7558]</b>
      </td>
      <td class="top"><a>Lynn, K.</a>, <a>Cheshire, S.</a>, <a>Blanchet, M.</a> and <a>D. Migault</a>, "<a href="http://tools.ietf.org/html/rfc7558">Requirements for Scalable DNS-Based Service Discovery (DNS-SD) / Multicast DNS (mDNS) Extensions</a>", RFC 7558, DOI 10.17487/RFC7558, July 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7575">[RFC7575]</b>
      </td>
      <td class="top"><a>Behringer, M.</a>, <a>Pritikin, M.</a>, <a>Bjarnason, S.</a>, <a>Clemm, A.</a>, <a>Carpenter, B.</a>, <a>Jiang, S.</a> and <a>L. Ciavaglia</a>, "<a href="http://tools.ietf.org/html/rfc7575">Autonomic Networking: Definitions and Design Goals</a>", RFC 7575, DOI 10.17487/RFC7575, June 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7576">[RFC7576]</b>
      </td>
      <td class="top"><a>Jiang, S.</a>, <a>Carpenter, B.</a> and <a>M. Behringer</a>, "<a href="http://tools.ietf.org/html/rfc7576">General Gap Analysis for Autonomic Networking</a>", RFC 7576, DOI 10.17487/RFC7576, June 2015.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#current" id="current">Capability Analysis of Current Protocols</a></h1>
<p id="rfc.section.A.p.1">This appendix discusses various existing protocols with properties related to the above negotiation and synchronisation requirements. The purpose is to evaluate whether any existing protocol, or a simple combination of existing protocols, can meet those requirements.</p>
<p id="rfc.section.A.p.2">Numerous protocols include some form of discovery, but these all appear to be very specific in their applicability. Service Location Protocol (SLP) <a href="#RFC2608">[RFC2608]</a> provides service discovery for managed networks, but requires configuration of its own servers. DNS-SD <a href="#RFC6763">[RFC6763]</a> combined with mDNS <a href="#RFC6762">[RFC6762]</a> provides service discovery for small networks with a single link layer. <a href="#RFC7558">[RFC7558]</a> aims to extend this to larger autonomous networks but this is not yet standardized. However, both SLP and DNS-SD appear to target primarily application layer services, not the layer 2 and 3 objectives relevant to basic network configuration. Both SLP and DNS-SD are text-based protocols. </p>
<p id="rfc.section.A.p.3">Routing protocols are mainly one-way information announcements. The receiver makes independent decisions based on the received information and there is no direct feedback information to the announcing peer. This remains true even though the protocol is used in both directions between peer routers; there is state synchronization, but no negotiation, and each peer runs its route calculations independently.</p>
<p id="rfc.section.A.p.4">Simple Network Management Protocol (SNMP) <a href="#RFC3416">[RFC3416]</a> uses a command/response model not well suited for peer negotiation. Network Configuration Protocol (NETCONF) <a href="#RFC6241">[RFC6241]</a> uses an RPC model that does allow positive or negative responses from the target system, but this is still not adequate for negotiation.</p>
<p id="rfc.section.A.p.5">There are various existing protocols that have elementary negotiation abilities, such as Dynamic Host Configuration Protocol for IPv6 (DHCPv6) <a href="#RFC3315">[RFC3315]</a>, Neighbor Discovery (ND) <a href="#RFC4861">[RFC4861]</a>, Port Control Protocol (PCP) <a href="#RFC6887">[RFC6887]</a>, Remote Authentication Dial In User Service (RADIUS) <a href="#RFC2865">[RFC2865]</a>, Diameter <a href="#RFC6733">[RFC6733]</a>, etc. Most of them are configuration or management protocols. However, they either provide only a simple request/response model in a master/slave context or very limited negotiation abilities.</p>
<p id="rfc.section.A.p.6">There are some signaling protocols with an element of negotiation.  For example Resource ReSerVation Protocol (RSVP) <a href="#RFC2205">[RFC2205]</a> was designed for negotiating quality of service parameters along the path of a unicast or multicast flow. RSVP is a very specialised protocol aimed at end-to-end flows. However, it has some flexibility, having been extended for MPLS label distribution <a href="#RFC3209">[RFC3209]</a>.  A more generic design is General Internet Signalling Transport (GIST) <a href="#RFC5971">[RFC5971]</a>, but it is complex, tries to solve many problems, and is also aimed at per-flow signaling across many hops rather than at device-to-device signaling.  However, we cannot completely exclude extended RSVP or GIST as a synchronization and negotiation protocol. They do not appear to be directly useable for peer discovery.</p>
<p id="rfc.section.A.p.7">We now consider two protocols that are works in progress at the time of this writing. Firstly, RESTCONF <a href="#I-D.ietf-netconf-restconf">[I-D.ietf-netconf-restconf]</a> is a protocol intended to convey NETCONF information expressed in the YANG language via HTTP, including the ability to transit HTML intermediaries. While this is a powerful approach in the context of centralised configuration of a complex network, it is not well adapted to efficient interactive negotiation between peer devices, especially simple ones that are unlikely to include YANG processing already.</p>
<p id="rfc.section.A.p.8">Secondly, we consider Distributed Node Consensus Protocol (DNCP) <a href="#I-D.ietf-homenet-dncp">[I-D.ietf-homenet-dncp]</a>. This is defined as a generic form of state synchronization protocol, with a proposed usage profile being the Home Networking Control Protocol (HNCP) <a href="#I-D.ietf-homenet-hncp">[I-D.ietf-homenet-hncp]</a> for configuring Homenet routers. A specific application of DNCP for autonomic networking was proposed in <a href="#I-D.stenberg-anima-adncp">[I-D.stenberg-anima-adncp]</a>.  </p>
<p id="rfc.section.A.p.9">DNCP "is designed to provide a way for each participating node to publish a set of TLV (Type-Length-Value) tuples, and to provide a shared and common view about the data published... DNCP is most suitable for data that changes only infrequently... If constant rapid state changes are needed, the preferable choice is to use an additional point-to-point channel..."</p>
<p id="rfc.section.A.p.10">Specific features of DNCP include: </p>

<ul>
  <li>Every participating node has a unique node identifier.</li>
  <li>DNCP messages are encoded as a sequence of TLV objects, sent over unicast UDP or TCP, with or without (D)TLS security.</li>
  <li>Multicast is used only for discovery of DNCP neighbors when lower security is acceptable.</li>
  <li>Synchronization of state is maintained by a flooding process using the Trickle algorithm.  There is no bilateral synchronization or negotiation capability.</li>
  <li>The HNCP profile of DNCP is designed to operate between directly connected neighbors on a shared link using UDP and link-local IPv6 addresses.</li>
</ul>

<p> DNCP does not meet the needs of a general negotiation protocol, because it is designed specifically for flooding synchronization. Also, in its HNCP profile it is limited to link-local messages and to IPv6. However, at the minimum it is a very interesting test case for this style of interaction between devices without needing a central authority, and it is a proven method of network-wide state synchronization by flooding.</p>
<p id="rfc.section.A.p.11">A proposal was made some years ago for an IP based Generic Control Protocol (IGCP) <a href="#I-D.chaparadza-intarea-igcp">[I-D.chaparadza-intarea-igcp]</a>. This was aimed at information exchange and negotiation but not directly at peer discovery. However, it has many points in common with the present work.</p>
<p id="rfc.section.A.p.12">None of the above solutions appears to completely meet the needs of generic discovery, state synchronization and negotiation in a single solution.  Many of the protocols assume that they are working in a traditional top-down or north-south scenario, rather than a fluid peer-to-peer scenario. Most of them are specialized in one way or another. As a result, we have not identified a combination of existing protocols that meets the requirements in <a href="#reqts">Section 2</a>. Also, we have not identified a path by which one of the existing protocols could be extended to meet the requirements.  </p>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Carsten Bormann</span> 
	  <span class="n hidden">
		<span class="family-name">Bormann</span>
	  </span>
	</span>
	<span class="org vcardline">Universit&#228;t Bremen TZI</span>
	<span class="adr">
	  <span class="vcardline">Postfach 330440</span>

	  <span class="vcardline">
		<span class="locality">D-28359 Bremen</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:cabo@tzi.org">cabo@tzi.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Brian Carpenter</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Carpenter</span>
	  </span>
	</span>
	<span class="org vcardline"></span>
	<span class="adr">
	  <span class="vcardline">Department of Computer Science</span>
<span class="vcardline">University of Auckland</span>
<span class="vcardline">PB 92019</span>

	  <span class="vcardline">
		<span class="locality">Auckland</span>,  
		<span class="region"></span>
		<span class="code">1142</span>
	  </span>
	  <span class="country-name vcardline">New Zealand</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:brian.e.carpenter@gmail.com">brian.e.carpenter@gmail.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Bing Liu</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Liu</span>
	  </span>
	</span>
	<span class="org vcardline">Huawei Technologies Co., Ltd</span>
	<span class="adr">
	  <span class="vcardline">Q14, Huawei Campus</span>
<span class="vcardline">No.156 Beiqing Road</span>

	  <span class="vcardline">
		<span class="locality">Hai-Dian District, Beijing</span>,  
		<span class="region"></span>
		<span class="code">100095</span>
	  </span>
	  <span class="country-name vcardline">P.R. China</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:leo.liubing@huawei.com">leo.liubing@huawei.com</a></span>

  </address>
</div>

</body>
</html>
